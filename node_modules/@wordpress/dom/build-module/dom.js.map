{"version":3,"sources":["@wordpress/dom/src/dom.js"],"names":["includes","noop","isPhrasingContent","getComputedStyle","node","ownerDocument","defaultView","getRangeHeight","range","rects","Array","from","getClientRects","length","highestTop","Math","min","map","top","lowestBottom","max","bottom","isSelectionForward","selection","anchorNode","focusNode","anchorOffset","focusOffset","position","compareDocumentPosition","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","isEdge","container","isReverse","onlyVertical","tagName","selectionStart","selectionEnd","value","isContentEditable","getSelection","rangeCount","getRangeAt","collapsedRange","cloneRange","isForward","isCollapsed","collapse","collapsedRangeRect","getRectangleFromRange","rangeRect","height","direction","isReverseDir","containerRect","getBoundingClientRect","x","left","right","y","testRange","hiddenCaretRangeFromPoint","testRect","verticalSide","horizontalSide","verticalDiff","horizontalDiff","hasVerticalDiff","abs","hasHorizontalDiff","isHorizontalEdge","isVerticalEdge","collapsed","startContainer","nodeName","parentNode","index","childNodes","indexOf","createRange","setStart","setEnd","rect","padNode","createTextNode","insertNode","removeChild","computeCaretRect","win","placeCaretAtHorizontalEdge","focus","rangeTarget","selectNodeContents","removeAllRanges","addRange","caretRangeFromPoint","doc","caretPositionFromPoint","point","offsetNode","offset","originalZIndex","style","zIndex","originalPosition","placeCaretAtVerticalEdge","mayUseScroll","buffer","editableRect","contains","scrollIntoView","isTextField","element","contentEditable","nonTextInputs","type","isNumberInput","valueAsNumber","documentHasTextSelection","inputFieldHasUncollapsedSelection","error","documentHasUncollapsedSelection","activeElement","documentHasSelection","isEntirelySelected","endContainer","startOffset","endOffset","lastChild","lastChildContentLength","nodeType","TEXT_NODE","data","firstChild","getScrollContainer","scrollHeight","clientHeight","overflowY","test","getOffsetParent","closestElement","ELEMENT_NODE","offsetParent","replace","processedNode","newNode","insertAfter","remove","referenceNode","insertBefore","nextSibling","unwrap","parent","replaceTag","createElement","appendChild","replaceChild","wrap","__unstableStripHTML","html","document","window","DOMParser","parseFromString","body","textContent","cleanNodeList","nodeList","schema","inline","forEach","tag","toLowerCase","hasOwnProperty","isMatch","attributes","classes","children","require","allowEmpty","isEmpty","hasAttributes","name","removeAttribute","classList","mattchers","item","className","RegExp","some","hasChildNodes","querySelector","join","child","nextElementSibling","every","nodeValue","trim","removeInvalidHTML","HTML","implementation","createHTMLDocument","innerHTML"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { includes, noop } from 'lodash';\n\n/**\n * Internal dependencies\n */\nimport { isPhrasingContent } from './phrasing-content';\n\nfunction getComputedStyle( node ) {\n\treturn node.ownerDocument.defaultView.getComputedStyle( node );\n}\n\n/**\n * Gets the height of the range without ignoring zero width rectangles, which\n * some browsers ignore when creating a union.\n *\n * @param {Range} range The range to check.\n */\nfunction getRangeHeight( range ) {\n\tconst rects = Array.from( range.getClientRects() );\n\n\tif ( ! rects.length ) {\n\t\treturn;\n\t}\n\n\tconst highestTop = Math.min( ...rects.map( ( { top } ) => top ) );\n\tconst lowestBottom = Math.max( ...rects.map( ( { bottom } ) => bottom ) );\n\n\treturn lowestBottom - highestTop;\n}\n\n/**\n * Returns true if the given selection object is in the forward direction, or\n * false otherwise.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n *\n * @param {Selection} selection Selection object to check.\n *\n * @return {boolean} Whether the selection is forward.\n */\nfunction isSelectionForward( selection ) {\n\tconst { anchorNode, focusNode, anchorOffset, focusOffset } = selection;\n\n\tconst position = anchorNode.compareDocumentPosition( focusNode );\n\n\t// Disable reason: `Node#compareDocumentPosition` returns a bitmask value,\n\t// so bitwise operators are intended.\n\t/* eslint-disable no-bitwise */\n\t// Compare whether anchor node precedes focus node. If focus node (where\n\t// end of selection occurs) is after the anchor node, it is forward.\n\tif ( position & anchorNode.DOCUMENT_POSITION_PRECEDING ) {\n\t\treturn false;\n\t}\n\n\tif ( position & anchorNode.DOCUMENT_POSITION_FOLLOWING ) {\n\t\treturn true;\n\t}\n\t/* eslint-enable no-bitwise */\n\n\t// `compareDocumentPosition` returns 0 when passed the same node, in which\n\t// case compare offsets.\n\tif ( position === 0 ) {\n\t\treturn anchorOffset <= focusOffset;\n\t}\n\n\t// This should never be reached, but return true as default case.\n\treturn true;\n}\n\n/**\n * Check whether the selection is at the edge of the container. Checks for\n * horizontal position by default. Set `onlyVertical` to true to check only\n * vertically.\n *\n * @param {Element} container    Focusable element.\n * @param {boolean} isReverse    Set to true to check left, false to check right.\n * @param {boolean} onlyVertical Set to true to check only vertical position.\n *\n * @return {boolean} True if at the edge, false if not.\n */\nfunction isEdge( container, isReverse, onlyVertical ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\tif ( container.selectionStart !== container.selectionEnd ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( isReverse ) {\n\t\t\treturn container.selectionStart === 0;\n\t\t}\n\n\t\treturn container.value.length === container.selectionStart;\n\t}\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst { ownerDocument } = container;\n\tconst { defaultView } = ownerDocument;\n\n\tconst selection = defaultView.getSelection();\n\n\tif ( ! selection.rangeCount ) {\n\t\treturn false;\n\t}\n\n\tconst range = selection.getRangeAt( 0 );\n\tconst collapsedRange = range.cloneRange();\n\tconst isForward = isSelectionForward( selection );\n\tconst isCollapsed = selection.isCollapsed;\n\n\t// Collapse in direction of selection.\n\tif ( ! isCollapsed ) {\n\t\tcollapsedRange.collapse( ! isForward );\n\t}\n\n\tconst collapsedRangeRect = getRectangleFromRange( collapsedRange );\n\tconst rangeRect = getRectangleFromRange( range );\n\n\tif ( ! collapsedRangeRect || ! rangeRect ) {\n\t\treturn false;\n\t}\n\n\t// Only consider the multiline selection at the edge if the direction is\n\t// towards the edge. The selection is multiline if it is taller than the\n\t// collapsed  selection.\n\tif (\n\t\t! isCollapsed &&\n\t\tgetRangeHeight( range ) > collapsedRangeRect.height &&\n\t\tisForward === isReverse\n\t) {\n\t\treturn false;\n\t}\n\n\t// In the case of RTL scripts, the horizontal edge is at the opposite side.\n\tconst { direction } = getComputedStyle( container );\n\tconst isReverseDir = direction === 'rtl' ? ! isReverse : isReverse;\n\n\tconst containerRect = container.getBoundingClientRect();\n\n\t// To check if a selection is at the edge, we insert a test selection at the\n\t// edge of the container and check if the selections have the same vertical\n\t// or horizontal position. If they do, the selection is at the edge.\n\t// This method proves to be better than a DOM-based calculation for the\n\t// horizontal edge, since it ignores empty textnodes and a trailing line\n\t// break element. In other words, we need to check visual positioning, not\n\t// DOM positioning.\n\t// It also proves better than using the computed style for the vertical\n\t// edge, because we cannot know the padding and line height reliably in\n\t// pixels. `getComputedStyle` may return a value with different units.\n\tconst x = isReverseDir ? containerRect.left + 1 : containerRect.right - 1;\n\tconst y = isReverse ? containerRect.top + 1 : containerRect.bottom - 1;\n\tconst testRange = hiddenCaretRangeFromPoint(\n\t\townerDocument,\n\t\tx,\n\t\ty,\n\t\tcontainer\n\t);\n\n\tif ( ! testRange ) {\n\t\treturn false;\n\t}\n\n\tconst testRect = getRectangleFromRange( testRange );\n\n\tif ( ! testRect ) {\n\t\treturn false;\n\t}\n\n\tconst verticalSide = isReverse ? 'top' : 'bottom';\n\tconst horizontalSide = isReverseDir ? 'left' : 'right';\n\tconst verticalDiff = testRect[ verticalSide ] - rangeRect[ verticalSide ];\n\tconst horizontalDiff =\n\t\ttestRect[ horizontalSide ] - collapsedRangeRect[ horizontalSide ];\n\n\t// Allow the position to be 1px off.\n\tconst hasVerticalDiff = Math.abs( verticalDiff ) <= 1;\n\tconst hasHorizontalDiff = Math.abs( horizontalDiff ) <= 1;\n\n\treturn onlyVertical\n\t\t? hasVerticalDiff\n\t\t: hasVerticalDiff && hasHorizontalDiff;\n}\n\n/**\n * Check whether the selection is horizontally at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check left, false for right.\n *\n * @return {boolean} True if at the horizontal edge, false if not.\n */\nexport function isHorizontalEdge( container, isReverse ) {\n\treturn isEdge( container, isReverse );\n}\n\n/**\n * Check whether the selection is vertically at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check top, false for bottom.\n *\n * @return {boolean} True if at the vertical edge, false if not.\n */\nexport function isVerticalEdge( container, isReverse ) {\n\treturn isEdge( container, isReverse, true );\n}\n\n/**\n * Get the rectangle of a given Range.\n *\n * @param {Range} range The range.\n *\n * @return {DOMRect} The rectangle.\n */\nexport function getRectangleFromRange( range ) {\n\t// For uncollapsed ranges, get the rectangle that bounds the contents of the\n\t// range; this a rectangle enclosing the union of the bounding rectangles\n\t// for all the elements in the range.\n\tif ( ! range.collapsed ) {\n\t\treturn range.getBoundingClientRect();\n\t}\n\n\tconst { startContainer } = range;\n\tconst { ownerDocument } = startContainer;\n\n\t// Correct invalid \"BR\" ranges. The cannot contain any children.\n\tif ( startContainer.nodeName === 'BR' ) {\n\t\tconst { parentNode } = startContainer;\n\t\tconst index = Array.from( parentNode.childNodes ).indexOf(\n\t\t\tstartContainer\n\t\t);\n\n\t\trange = ownerDocument.createRange();\n\t\trange.setStart( parentNode, index );\n\t\trange.setEnd( parentNode, index );\n\t}\n\n\tlet rect = range.getClientRects()[ 0 ];\n\n\t// If the collapsed range starts (and therefore ends) at an element node,\n\t// `getClientRects` can be empty in some browsers. This can be resolved\n\t// by adding a temporary text node with zero-width space to the range.\n\t//\n\t// See: https://stackoverflow.com/a/6847328/995445\n\tif ( ! rect ) {\n\t\tconst padNode = ownerDocument.createTextNode( '\\u200b' );\n\t\t// Do not modify the live range.\n\t\trange = range.cloneRange();\n\t\trange.insertNode( padNode );\n\t\trect = range.getClientRects()[ 0 ];\n\t\tpadNode.parentNode.removeChild( padNode );\n\t}\n\n\treturn rect;\n}\n\n/**\n * Get the rectangle for the selection in a container.\n *\n * @param {Window} win The window of the selection.\n *\n * @return {?DOMRect} The rectangle.\n */\nexport function computeCaretRect( win ) {\n\tconst selection = win.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\treturn getRectangleFromRange( range );\n}\n\n/**\n * Places the caret at start or end of a given element.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse True for end, false for start.\n */\nexport function placeCaretAtHorizontalEdge( container, isReverse ) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\tcontainer.focus();\n\t\tif ( isReverse ) {\n\t\t\tcontainer.selectionStart = container.value.length;\n\t\t\tcontainer.selectionEnd = container.value.length;\n\t\t} else {\n\t\t\tcontainer.selectionStart = 0;\n\t\t\tcontainer.selectionEnd = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tcontainer.focus();\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn;\n\t}\n\n\t// Select on extent child of the container, not the container itself. This\n\t// avoids the selection always being `endOffset` of 1 when placed at end,\n\t// where `startContainer`, `endContainer` would always be container itself.\n\tconst rangeTarget = container[ isReverse ? 'lastChild' : 'firstChild' ];\n\n\t// If no range target, it implies that the container is empty. Focusing is\n\t// sufficient for caret to be placed correctly.\n\tif ( ! rangeTarget ) {\n\t\treturn;\n\t}\n\n\tconst { ownerDocument } = container;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView.getSelection();\n\tconst range = ownerDocument.createRange();\n\n\trange.selectNodeContents( rangeTarget );\n\trange.collapse( ! isReverse );\n\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n\n/**\n * Polyfill.\n * Get a collapsed range for a given point.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n *\n * @param {Document} doc  The document of the range.\n * @param {number}   x    Horizontal position within the current viewport.\n * @param {number}   y    Vertical position within the current viewport.\n *\n * @return {?Range} The best range for the given point.\n */\nfunction caretRangeFromPoint( doc, x, y ) {\n\tif ( doc.caretRangeFromPoint ) {\n\t\treturn doc.caretRangeFromPoint( x, y );\n\t}\n\n\tif ( ! doc.caretPositionFromPoint ) {\n\t\treturn null;\n\t}\n\n\tconst point = doc.caretPositionFromPoint( x, y );\n\n\t// If x or y are negative, outside viewport, or there is no text entry node.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n\tif ( ! point ) {\n\t\treturn null;\n\t}\n\n\tconst range = doc.createRange();\n\n\trange.setStart( point.offsetNode, point.offset );\n\trange.collapse( true );\n\n\treturn range;\n}\n\n/**\n * Get a collapsed range for a given point.\n * Gives the container a temporary high z-index (above any UI).\n * This is preferred over getting the UI nodes and set styles there.\n *\n * @param {Document} doc       The document of the range.\n * @param {number}    x         Horizontal position within the current viewport.\n * @param {number}    y         Vertical position within the current viewport.\n * @param {Element}  container Container in which the range is expected to be found.\n *\n * @return {?Range} The best range for the given point.\n */\nfunction hiddenCaretRangeFromPoint( doc, x, y, container ) {\n\tconst originalZIndex = container.style.zIndex;\n\tconst originalPosition = container.style.position;\n\n\t// A z-index only works if the element position is not static.\n\tcontainer.style.zIndex = '10000';\n\tcontainer.style.position = 'relative';\n\n\tconst range = caretRangeFromPoint( doc, x, y );\n\n\tcontainer.style.zIndex = originalZIndex;\n\tcontainer.style.position = originalPosition;\n\n\treturn range;\n}\n\n/**\n * Places the caret at the top or bottom of a given element.\n *\n * @param {Element} container           Focusable element.\n * @param {boolean} isReverse           True for bottom, false for top.\n * @param {DOMRect} [rect]              The rectangle to position the caret with.\n * @param {boolean} [mayUseScroll=true] True to allow scrolling, false to disallow.\n */\nexport function placeCaretAtVerticalEdge(\n\tcontainer,\n\tisReverse,\n\trect,\n\tmayUseScroll = true\n) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tif ( ! rect || ! container.isContentEditable ) {\n\t\tplaceCaretAtHorizontalEdge( container, isReverse );\n\t\treturn;\n\t}\n\n\t// Offset by a buffer half the height of the caret rect. This is needed\n\t// because caretRangeFromPoint may default to the end of the selection if\n\t// offset is too close to the edge. It's unclear how to precisely calculate\n\t// this threshold; it may be the padded area of some combination of line\n\t// height, caret height, and font size. The buffer offset is effectively\n\t// equivalent to a point at half the height of a line of text.\n\tconst buffer = rect.height / 2;\n\tconst editableRect = container.getBoundingClientRect();\n\tconst x = rect.left;\n\tconst y = isReverse\n\t\t? editableRect.bottom - buffer\n\t\t: editableRect.top + buffer;\n\n\tconst { ownerDocument } = container;\n\tconst { defaultView } = ownerDocument;\n\tconst range = hiddenCaretRangeFromPoint( ownerDocument, x, y, container );\n\n\tif ( ! range || ! container.contains( range.startContainer ) ) {\n\t\tif (\n\t\t\tmayUseScroll &&\n\t\t\t( ! range ||\n\t\t\t\t! range.startContainer ||\n\t\t\t\t! range.startContainer.contains( container ) )\n\t\t) {\n\t\t\t// Might be out of view.\n\t\t\t// Easier than attempting to calculate manually.\n\t\t\tcontainer.scrollIntoView( isReverse );\n\t\t\tplaceCaretAtVerticalEdge( container, isReverse, rect, false );\n\t\t\treturn;\n\t\t}\n\n\t\tplaceCaretAtHorizontalEdge( container, isReverse );\n\t\treturn;\n\t}\n\n\tconst selection = defaultView.getSelection();\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n\tcontainer.focus();\n\t// Editable was already focussed, it goes back to old range...\n\t// This fixes it.\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n\n/**\n * Check whether the given element is a text field, where text field is defined\n * by the ability to select within the input, or that it is contenteditable.\n *\n * See: https://html.spec.whatwg.org/#textFieldSelection\n *\n * @param {HTMLElement} element The HTML element.\n *\n * @return {boolean} True if the element is an text field, false if not.\n */\nexport function isTextField( element ) {\n\tconst { nodeName, contentEditable } = element;\n\tconst nonTextInputs = [\n\t\t'button',\n\t\t'checkbox',\n\t\t'hidden',\n\t\t'file',\n\t\t'radio',\n\t\t'image',\n\t\t'range',\n\t\t'reset',\n\t\t'submit',\n\t\t'number',\n\t];\n\treturn (\n\t\t( nodeName === 'INPUT' && ! nonTextInputs.includes( element.type ) ) ||\n\t\tnodeName === 'TEXTAREA' ||\n\t\tcontentEditable === 'true'\n\t);\n}\n\n/**\n * Check whether the given element is an input field of type number\n * and has a valueAsNumber\n *\n * @param {HTMLElement} element The HTML element.\n *\n * @return {boolean} True if the element is input and holds a number.\n */\nexport function isNumberInput( element ) {\n\tconst { nodeName, type, valueAsNumber } = element;\n\n\treturn nodeName === 'INPUT' && type === 'number' && !! valueAsNumber;\n}\n\n/**\n * Check whether the current document has selected text. This applies to ranges\n * of text in the document, and not selection inside <input> and <textarea>\n * elements.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection#Related_objects.\n *\n * @param {Document} doc The document to check.\n *\n * @return {boolean} True if there is selection, false if not.\n */\nexport function documentHasTextSelection( doc ) {\n\tconst selection = doc.defaultView.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\treturn range && ! range.collapsed;\n}\n\n/**\n * Check whether the given element, assumed an input field or textarea,\n * contains a (uncollapsed) selection of text.\n *\n * Note: this is perhaps an abuse of the term \"selection\", since these elements\n * manage selection differently and aren't covered by Selection#collapsed.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection#Related_objects.\n *\n * @param {HTMLElement} element The HTML element.\n *\n * @return {boolean} Whether the input/textareaa element has some \"selection\".\n */\nfunction inputFieldHasUncollapsedSelection( element ) {\n\tif ( ! isTextField( element ) && ! isNumberInput( element ) ) {\n\t\treturn false;\n\t}\n\ttry {\n\t\tconst { selectionStart, selectionEnd } = element;\n\n\t\treturn selectionStart !== null && selectionStart !== selectionEnd;\n\t} catch ( error ) {\n\t\t// Safari throws an exception when trying to get `selectionStart`\n\t\t// on non-text <input> elements (which, understandably, don't\n\t\t// have the text selection API). We catch this via a try/catch\n\t\t// block, as opposed to a more explicit check of the element's\n\t\t// input types, because of Safari's non-standard behavior. This\n\t\t// also means we don't have to worry about the list of input\n\t\t// types that support `selectionStart` changing as the HTML spec\n\t\t// evolves over time.\n\t\treturn false;\n\t}\n}\n\n/**\n * Check whether the current document has any sort of selection. This includes\n * ranges of text across elements and any selection inside <input> and\n * <textarea> elements.\n *\n * @param {Document} doc The document to check.\n *\n * @return {boolean} Whether there is any sort of \"selection\" in the document.\n */\nexport function documentHasUncollapsedSelection( doc ) {\n\treturn (\n\t\tdocumentHasTextSelection( doc ) ||\n\t\tinputFieldHasUncollapsedSelection( doc.activeElement )\n\t);\n}\n\n/**\n * Check whether the current document has a selection. This checks for both\n * focus in an input field and general text selection.\n *\n * @param {Document} doc The document to check.\n *\n * @return {boolean} True if there is selection, false if not.\n */\nexport function documentHasSelection( doc ) {\n\treturn (\n\t\tisTextField( doc.activeElement ) ||\n\t\tisNumberInput( doc.activeElement ) ||\n\t\tdocumentHasTextSelection( doc )\n\t);\n}\n\n/**\n * Check whether the contents of the element have been entirely selected.\n * Returns true if there is no possibility of selection.\n *\n * @param {Element} element The element to check.\n *\n * @return {boolean} True if entirely selected, false if not.\n */\nexport function isEntirelySelected( element ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], element.nodeName ) ) {\n\t\treturn (\n\t\t\telement.selectionStart === 0 &&\n\t\t\telement.value.length === element.selectionEnd\n\t\t);\n\t}\n\n\tif ( ! element.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst { ownerDocument } = element;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn true;\n\t}\n\n\tconst { startContainer, endContainer, startOffset, endOffset } = range;\n\n\tif (\n\t\tstartContainer === element &&\n\t\tendContainer === element &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === element.childNodes.length\n\t) {\n\t\treturn true;\n\t}\n\n\tconst lastChild = element.lastChild;\n\tconst lastChildContentLength =\n\t\tlastChild.nodeType === lastChild.TEXT_NODE\n\t\t\t? lastChild.data.length\n\t\t\t: lastChild.childNodes.length;\n\n\treturn (\n\t\tstartContainer === element.firstChild &&\n\t\tendContainer === element.lastChild &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === lastChildContentLength\n\t);\n}\n\n/**\n * Given a DOM node, finds the closest scrollable container node.\n *\n * @param {Element} node Node from which to start.\n *\n * @return {?Element} Scrollable container node, if found.\n */\nexport function getScrollContainer( node ) {\n\tif ( ! node ) {\n\t\treturn;\n\t}\n\n\t// Scrollable if scrollable height exceeds displayed...\n\tif ( node.scrollHeight > node.clientHeight ) {\n\t\t// ...except when overflow is defined to be hidden or visible\n\t\tconst { overflowY } = getComputedStyle( node );\n\t\tif ( /(auto|scroll)/.test( overflowY ) ) {\n\t\t\treturn node;\n\t\t}\n\t}\n\n\t// Continue traversing\n\treturn getScrollContainer( node.parentNode );\n}\n\n/**\n * Returns the closest positioned element, or null under any of the conditions\n * of the offsetParent specification. Unlike offsetParent, this function is not\n * limited to HTMLElement and accepts any Node (e.g. Node.TEXT_NODE).\n *\n * @see https://drafts.csswg.org/cssom-view/#dom-htmlelement-offsetparent\n *\n * @param {Node} node Node from which to find offset parent.\n *\n * @return {?Node} Offset parent.\n */\nexport function getOffsetParent( node ) {\n\t// Cannot retrieve computed style or offset parent only anything other than\n\t// an element node, so find the closest element node.\n\tlet closestElement;\n\twhile ( ( closestElement = node.parentNode ) ) {\n\t\tif ( closestElement.nodeType === closestElement.ELEMENT_NODE ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( ! closestElement ) {\n\t\treturn null;\n\t}\n\n\t// If the closest element is already positioned, return it, as offsetParent\n\t// does not otherwise consider the node itself.\n\tif ( getComputedStyle( closestElement ).position !== 'static' ) {\n\t\treturn closestElement;\n\t}\n\n\treturn closestElement.offsetParent;\n}\n\n/**\n * Given two DOM nodes, replaces the former with the latter in the DOM.\n *\n * @param {Element} processedNode Node to be removed.\n * @param {Element} newNode       Node to be inserted in its place.\n * @return {void}\n */\nexport function replace( processedNode, newNode ) {\n\tinsertAfter( newNode, processedNode.parentNode );\n\tremove( processedNode );\n}\n\n/**\n * Given a DOM node, removes it from the DOM.\n *\n * @param {Element} node Node to be removed.\n * @return {void}\n */\nexport function remove( node ) {\n\tnode.parentNode.removeChild( node );\n}\n\n/**\n * Given two DOM nodes, inserts the former in the DOM as the next sibling of\n * the latter.\n *\n * @param {Element} newNode       Node to be inserted.\n * @param {Element} referenceNode Node after which to perform the insertion.\n * @return {void}\n */\nexport function insertAfter( newNode, referenceNode ) {\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode.nextSibling );\n}\n\n/**\n * Unwrap the given node. This means any child nodes are moved to the parent.\n *\n * @param {Node} node The node to unwrap.\n *\n * @return {void}\n */\nexport function unwrap( node ) {\n\tconst parent = node.parentNode;\n\n\twhile ( node.firstChild ) {\n\t\tparent.insertBefore( node.firstChild, node );\n\t}\n\n\tparent.removeChild( node );\n}\n\n/**\n * Replaces the given node with a new node with the given tag name.\n *\n * @param {Element}  node    The node to replace\n * @param {string}   tagName The new tag name.\n *\n * @return {Element} The new node.\n */\nexport function replaceTag( node, tagName ) {\n\tconst newNode = node.ownerDocument.createElement( tagName );\n\n\twhile ( node.firstChild ) {\n\t\tnewNode.appendChild( node.firstChild );\n\t}\n\n\tnode.parentNode.replaceChild( newNode, node );\n\n\treturn newNode;\n}\n\n/**\n * Wraps the given node with a new node with the given tag name.\n *\n * @param {Element} newNode       The node to insert.\n * @param {Element} referenceNode The node to wrap.\n */\nexport function wrap( newNode, referenceNode ) {\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode );\n\tnewNode.appendChild( referenceNode );\n}\n\n/**\n * Removes any HTML tags from the provided string.\n *\n * @param {string} html The string containing html.\n *\n * @return {string} The text content with any html removed.\n */\nexport function __unstableStripHTML( html ) {\n\tconst document = new window.DOMParser().parseFromString(\n\t\thtml,\n\t\t'text/html'\n\t);\n\treturn document.body.textContent || '';\n}\n\n/**\n * Given a schema, unwraps or removes nodes, attributes and classes on a node\n * list.\n *\n * @param {NodeList} nodeList The nodeList to filter.\n * @param {Document} doc      The document of the nodeList.\n * @param {Object}   schema   An array of functions that can mutate with the provided node.\n * @param {Object}   inline   Whether to clean for inline mode.\n */\nfunction cleanNodeList( nodeList, doc, schema, inline ) {\n\tArray.from( nodeList ).forEach( ( node ) => {\n\t\tconst tag = node.nodeName.toLowerCase();\n\n\t\t// It's a valid child, if the tag exists in the schema without an isMatch\n\t\t// function, or with an isMatch function that matches the node.\n\t\tif (\n\t\t\tschema.hasOwnProperty( tag ) &&\n\t\t\t( ! schema[ tag ].isMatch || schema[ tag ].isMatch( node ) )\n\t\t) {\n\t\t\tif ( node.nodeType === node.ELEMENT_NODE ) {\n\t\t\t\tconst {\n\t\t\t\t\tattributes = [],\n\t\t\t\t\tclasses = [],\n\t\t\t\t\tchildren,\n\t\t\t\t\trequire = [],\n\t\t\t\t\tallowEmpty,\n\t\t\t\t} = schema[ tag ];\n\n\t\t\t\t// If the node is empty and it's supposed to have children,\n\t\t\t\t// remove the node.\n\t\t\t\tif ( children && ! allowEmpty && isEmpty( node ) ) {\n\t\t\t\t\tremove( node );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( node.hasAttributes() ) {\n\t\t\t\t\t// Strip invalid attributes.\n\t\t\t\t\tArray.from( node.attributes ).forEach( ( { name } ) => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tname !== 'class' &&\n\t\t\t\t\t\t\t! includes( attributes, name )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnode.removeAttribute( name );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t\t// Strip invalid classes.\n\t\t\t\t\t// In jsdom-jscore, 'node.classList' can be undefined.\n\t\t\t\t\t// TODO: Explore patching this in jsdom-jscore.\n\t\t\t\t\tif ( node.classList && node.classList.length ) {\n\t\t\t\t\t\tconst mattchers = classes.map( ( item ) => {\n\t\t\t\t\t\t\tif ( typeof item === 'string' ) {\n\t\t\t\t\t\t\t\treturn ( className ) => className === item;\n\t\t\t\t\t\t\t} else if ( item instanceof RegExp ) {\n\t\t\t\t\t\t\t\treturn ( className ) => item.test( className );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn noop;\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tArray.from( node.classList ).forEach( ( name ) => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t! mattchers.some( ( isMatch ) =>\n\t\t\t\t\t\t\t\t\tisMatch( name )\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tnode.classList.remove( name );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tif ( ! node.classList.length ) {\n\t\t\t\t\t\t\tnode.removeAttribute( 'class' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( node.hasChildNodes() ) {\n\t\t\t\t\t// Do not filter any content.\n\t\t\t\t\tif ( children === '*' ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Continue if the node is supposed to have children.\n\t\t\t\t\tif ( children ) {\n\t\t\t\t\t\t// If a parent requires certain children, but it does\n\t\t\t\t\t\t// not have them, drop the parent and continue.\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\trequire.length &&\n\t\t\t\t\t\t\t! node.querySelector( require.join( ',' ) )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tunwrap( node );\n\t\t\t\t\t\t\t// If the node is at the top, phrasing content, and\n\t\t\t\t\t\t\t// contains children that are block content, unwrap\n\t\t\t\t\t\t\t// the node because it is invalid.\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tnode.parentNode.nodeName === 'BODY' &&\n\t\t\t\t\t\t\tisPhrasingContent( node )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tArray.from( node.childNodes ).some(\n\t\t\t\t\t\t\t\t\t( child ) => ! isPhrasingContent( child )\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tunwrap( node );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\tchildren,\n\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Remove children if the node is not supposed to have any.\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile ( node.firstChild ) {\n\t\t\t\t\t\t\tremove( node.firstChild );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Invalid child. Continue with schema at the same place and unwrap.\n\t\t} else {\n\t\t\tcleanNodeList( node.childNodes, doc, schema, inline );\n\n\t\t\t// For inline mode, insert a line break when unwrapping nodes that\n\t\t\t// are not phrasing content.\n\t\t\tif (\n\t\t\t\tinline &&\n\t\t\t\t! isPhrasingContent( node ) &&\n\t\t\t\tnode.nextElementSibling\n\t\t\t) {\n\t\t\t\tinsertAfter( doc.createElement( 'br' ), node );\n\t\t\t}\n\n\t\t\tunwrap( node );\n\t\t}\n\t} );\n}\n\n/**\n * Recursively checks if an element is empty. An element is not empty if it\n * contains text or contains elements with attributes such as images.\n *\n * @param {Element} element The element to check.\n *\n * @return {boolean} Whether or not the element is empty.\n */\nexport function isEmpty( element ) {\n\tif ( ! element.hasChildNodes() ) {\n\t\treturn true;\n\t}\n\n\treturn Array.from( element.childNodes ).every( ( node ) => {\n\t\tif ( node.nodeType === node.TEXT_NODE ) {\n\t\t\treturn ! node.nodeValue.trim();\n\t\t}\n\n\t\tif ( node.nodeType === node.ELEMENT_NODE ) {\n\t\t\tif ( node.nodeName === 'BR' ) {\n\t\t\t\treturn true;\n\t\t\t} else if ( node.hasAttributes() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEmpty( node );\n\t\t}\n\n\t\treturn true;\n\t} );\n}\n\n/**\n * Given a schema, unwraps or removes nodes, attributes and classes on HTML.\n *\n * @param {string} HTML   The HTML to clean up.\n * @param {Object} schema Schema for the HTML.\n * @param {Object} inline Whether to clean for inline mode.\n *\n * @return {string} The cleaned up HTML.\n */\nexport function removeInvalidHTML( HTML, schema, inline ) {\n\tconst doc = document.implementation.createHTMLDocument( '' );\n\n\tdoc.body.innerHTML = HTML;\n\n\tcleanNodeList( doc.body.childNodes, doc, schema, inline );\n\n\treturn doc.body.innerHTML;\n}\n"]}