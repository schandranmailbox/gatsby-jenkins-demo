import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import { createElement } from "@wordpress/element";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * External dependencies
 */
import classnames from 'classnames';
/**
 * WordPress dependencies
 */

import { useEffect, useState } from '@wordpress/element';
import { InspectorControls, BlockControls, RichText, PanelColorSettings, createCustomColorsHOC, BlockIcon, AlignmentToolbar, useBlockProps } from '@wordpress/block-editor';
import { __ } from '@wordpress/i18n';
import { Button, DropdownMenu, PanelBody, Placeholder, TextControl, ToggleControl, ToolbarGroup, ToolbarItem } from '@wordpress/components';
import { alignLeft, alignRight, alignCenter, blockTable as icon, tableColumnAfter, tableColumnBefore, tableColumnDelete, tableRowAfter, tableRowBefore, tableRowDelete, table } from '@wordpress/icons';
import { createBlock } from '@wordpress/blocks';
/**
 * Internal dependencies
 */

import { createTable, updateSelectedCell, getCellAttribute, insertRow, deleteRow, insertColumn, deleteColumn, toggleSection, isEmptyTableSection } from './state';
var BACKGROUND_COLORS = [{
  color: '#f3f4f5',
  name: 'Subtle light gray',
  slug: 'subtle-light-gray'
}, {
  color: '#e9fbe5',
  name: 'Subtle pale green',
  slug: 'subtle-pale-green'
}, {
  color: '#e7f5fe',
  name: 'Subtle pale blue',
  slug: 'subtle-pale-blue'
}, {
  color: '#fcf0ef',
  name: 'Subtle pale pink',
  slug: 'subtle-pale-pink'
}];
var ALIGNMENT_CONTROLS = [{
  icon: alignLeft,
  title: __('Align column left'),
  align: 'left'
}, {
  icon: alignCenter,
  title: __('Align column center'),
  align: 'center'
}, {
  icon: alignRight,
  title: __('Align column right'),
  align: 'right'
}];
var withCustomBackgroundColors = createCustomColorsHOC(BACKGROUND_COLORS);
var cellAriaLabel = {
  head: __('Header cell text'),
  body: __('Body cell text'),
  foot: __('Footer cell text')
};
var placeholder = {
  head: __('Header label'),
  foot: __('Footer label')
};

function TSection(_ref) {
  var name = _ref.name,
      props = _objectWithoutProperties(_ref, ["name"]);

  var TagName = "t".concat(name);
  return createElement(TagName, props);
}

function TableEdit(_ref2) {
  var attributes = _ref2.attributes,
      backgroundColor = _ref2.backgroundColor,
      setBackgroundColor = _ref2.setBackgroundColor,
      setAttributes = _ref2.setAttributes,
      insertBlocksAfter = _ref2.insertBlocksAfter,
      isSelected = _ref2.isSelected;
  var hasFixedLayout = attributes.hasFixedLayout,
      caption = attributes.caption,
      head = attributes.head,
      foot = attributes.foot;

  var _useState = useState(2),
      _useState2 = _slicedToArray(_useState, 2),
      initialRowCount = _useState2[0],
      setInitialRowCount = _useState2[1];

  var _useState3 = useState(2),
      _useState4 = _slicedToArray(_useState3, 2),
      initialColumnCount = _useState4[0],
      setInitialColumnCount = _useState4[1];

  var _useState5 = useState(),
      _useState6 = _slicedToArray(_useState5, 2),
      selectedCell = _useState6[0],
      setSelectedCell = _useState6[1];
  /**
   * Updates the initial column count used for table creation.
   *
   * @param {number} count New initial column count.
   */


  function onChangeInitialColumnCount(count) {
    setInitialColumnCount(count);
  }
  /**
   * Updates the initial row count used for table creation.
   *
   * @param {number} count New initial row count.
   */


  function onChangeInitialRowCount(count) {
    setInitialRowCount(count);
  }
  /**
   * Creates a table based on dimensions in local state.
   *
   * @param {Object} event Form submit event.
   */


  function onCreateTable(event) {
    event.preventDefault();
    setAttributes(createTable({
      rowCount: parseInt(initialRowCount, 10) || 2,
      columnCount: parseInt(initialColumnCount, 10) || 2
    }));
  }
  /**
   * Toggles whether the table has a fixed layout or not.
   */


  function onChangeFixedLayout() {
    setAttributes({
      hasFixedLayout: !hasFixedLayout
    });
  }
  /**
   * Changes the content of the currently selected cell.
   *
   * @param {Array} content A RichText content value.
   */


  function onChange(content) {
    if (!selectedCell) {
      return;
    }

    setAttributes(updateSelectedCell(attributes, selectedCell, function (cellAttributes) {
      return _objectSpread(_objectSpread({}, cellAttributes), {}, {
        content: content
      });
    }));
  }
  /**
   * Align text within the a column.
   *
   * @param {string} align The new alignment to apply to the column.
   */


  function onChangeColumnAlignment(align) {
    if (!selectedCell) {
      return;
    } // Convert the cell selection to a column selection so that alignment
    // is applied to the entire column.


    var columnSelection = {
      type: 'column',
      columnIndex: selectedCell.columnIndex
    };
    var newAttributes = updateSelectedCell(attributes, columnSelection, function (cellAttributes) {
      return _objectSpread(_objectSpread({}, cellAttributes), {}, {
        align: align
      });
    });
    setAttributes(newAttributes);
  }
  /**
   * Get the alignment of the currently selected cell.
   *
   * @return {string} The new alignment to apply to the column.
   */


  function getCellAlignment() {
    if (!selectedCell) {
      return;
    }

    return getCellAttribute(attributes, selectedCell, 'align');
  }
  /**
   * Add or remove a `head` table section.
   */


  function onToggleHeaderSection() {
    setAttributes(toggleSection(attributes, 'head'));
  }
  /**
   * Add or remove a `foot` table section.
   */


  function onToggleFooterSection() {
    setAttributes(toggleSection(attributes, 'foot'));
  }
  /**
   * Inserts a row at the currently selected row index, plus `delta`.
   *
   * @param {number} delta Offset for selected row index at which to insert.
   */


  function onInsertRow(delta) {
    if (!selectedCell) {
      return;
    }

    var sectionName = selectedCell.sectionName,
        rowIndex = selectedCell.rowIndex;
    var newRowIndex = rowIndex + delta;
    setAttributes(insertRow(attributes, {
      sectionName: sectionName,
      rowIndex: newRowIndex
    })); // Select the first cell of the new row

    setSelectedCell({
      sectionName: sectionName,
      rowIndex: newRowIndex,
      columnIndex: 0,
      type: 'cell'
    });
  }
  /**
   * Inserts a row before the currently selected row.
   */


  function onInsertRowBefore() {
    onInsertRow(0);
  }
  /**
   * Inserts a row after the currently selected row.
   */


  function onInsertRowAfter() {
    onInsertRow(1);
  }
  /**
   * Deletes the currently selected row.
   */


  function onDeleteRow() {
    if (!selectedCell) {
      return;
    }

    var sectionName = selectedCell.sectionName,
        rowIndex = selectedCell.rowIndex;
    setSelectedCell();
    setAttributes(deleteRow(attributes, {
      sectionName: sectionName,
      rowIndex: rowIndex
    }));
  }
  /**
   * Inserts a column at the currently selected column index, plus `delta`.
   *
   * @param {number} delta Offset for selected column index at which to insert.
   */


  function onInsertColumn() {
    var delta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    if (!selectedCell) {
      return;
    }

    var columnIndex = selectedCell.columnIndex;
    var newColumnIndex = columnIndex + delta;
    setAttributes(insertColumn(attributes, {
      columnIndex: newColumnIndex
    })); // Select the first cell of the new column

    setSelectedCell({
      rowIndex: 0,
      columnIndex: newColumnIndex,
      type: 'cell'
    });
  }
  /**
   * Inserts a column before the currently selected column.
   */


  function onInsertColumnBefore() {
    onInsertColumn(0);
  }
  /**
   * Inserts a column after the currently selected column.
   */


  function onInsertColumnAfter() {
    onInsertColumn(1);
  }
  /**
   * Deletes the currently selected column.
   */


  function onDeleteColumn() {
    if (!selectedCell) {
      return;
    }

    var sectionName = selectedCell.sectionName,
        columnIndex = selectedCell.columnIndex;
    setSelectedCell();
    setAttributes(deleteColumn(attributes, {
      sectionName: sectionName,
      columnIndex: columnIndex
    }));
  }

  useEffect(function () {
    if (!isSelected) {
      setSelectedCell();
    }
  }, [isSelected]);
  var sections = ['head', 'body', 'foot'].filter(function (name) {
    return !isEmptyTableSection(attributes[name]);
  });
  var tableControls = [{
    icon: tableRowBefore,
    title: __('Insert row before'),
    isDisabled: !selectedCell,
    onClick: onInsertRowBefore
  }, {
    icon: tableRowAfter,
    title: __('Insert row after'),
    isDisabled: !selectedCell,
    onClick: onInsertRowAfter
  }, {
    icon: tableRowDelete,
    title: __('Delete row'),
    isDisabled: !selectedCell,
    onClick: onDeleteRow
  }, {
    icon: tableColumnBefore,
    title: __('Insert column before'),
    isDisabled: !selectedCell,
    onClick: onInsertColumnBefore
  }, {
    icon: tableColumnAfter,
    title: __('Insert column after'),
    isDisabled: !selectedCell,
    onClick: onInsertColumnAfter
  }, {
    icon: tableColumnDelete,
    title: __('Delete column'),
    isDisabled: !selectedCell,
    onClick: onDeleteColumn
  }];
  var renderedSections = ['head', 'body', 'foot'].map(function (name) {
    return createElement(TSection, {
      name: name,
      key: name
    }, attributes[name].map(function (_ref3, rowIndex) {
      var cells = _ref3.cells;
      return createElement("tr", {
        key: rowIndex
      }, cells.map(function (_ref4, columnIndex) {
        var content = _ref4.content,
            CellTag = _ref4.tag,
            scope = _ref4.scope,
            align = _ref4.align;
        return createElement(RichText, {
          tagName: CellTag,
          key: columnIndex,
          className: classnames(_defineProperty({}, "has-text-align-".concat(align), align), 'wp-block-table__cell-content'),
          scope: CellTag === 'th' ? scope : undefined,
          value: content,
          onChange: onChange,
          unstableOnFocus: function unstableOnFocus() {
            setSelectedCell({
              sectionName: name,
              rowIndex: rowIndex,
              columnIndex: columnIndex,
              type: 'cell'
            });
          },
          "aria-label": cellAriaLabel[name],
          placeholder: placeholder[name]
        });
      }));
    }));
  });
  var isEmpty = !sections.length;
  return createElement("figure", useBlockProps(), !isEmpty && createElement(BlockControls, null, createElement(ToolbarGroup, null, createElement(ToolbarItem, null, function (toggleProps) {
    return createElement(DropdownMenu, {
      hasArrowIndicator: true,
      icon: table,
      toggleProps: toggleProps,
      label: __('Edit table'),
      controls: tableControls
    });
  })), createElement(AlignmentToolbar, {
    label: __('Change column alignment'),
    alignmentControls: ALIGNMENT_CONTROLS,
    value: getCellAlignment(),
    onChange: function onChange(nextAlign) {
      return onChangeColumnAlignment(nextAlign);
    }
  })), !isEmpty && createElement(InspectorControls, null, createElement(PanelBody, {
    title: __('Table settings'),
    className: "blocks-table-settings"
  }, createElement(ToggleControl, {
    label: __('Fixed width table cells'),
    checked: !!hasFixedLayout,
    onChange: onChangeFixedLayout
  }), createElement(ToggleControl, {
    label: __('Header section'),
    checked: !!(head && head.length),
    onChange: onToggleHeaderSection
  }), createElement(ToggleControl, {
    label: __('Footer section'),
    checked: !!(foot && foot.length),
    onChange: onToggleFooterSection
  })), createElement(PanelColorSettings, {
    title: __('Color settings'),
    initialOpen: false,
    colorSettings: [{
      value: backgroundColor.color,
      onChange: setBackgroundColor,
      label: __('Background color'),
      disableCustomColors: true,
      colors: BACKGROUND_COLORS
    }]
  })), !isEmpty && createElement("table", {
    className: classnames(backgroundColor.class, {
      'has-fixed-layout': hasFixedLayout,
      'has-background': !!backgroundColor.color
    })
  }, renderedSections), !isEmpty && createElement(RichText, {
    tagName: "figcaption",
    "aria-label": __('Table caption text'),
    placeholder: __('Write caption…'),
    value: caption,
    onChange: function onChange(value) {
      return setAttributes({
        caption: value
      });
    } // Deselect the selected table cell when the caption is focused.
    ,
    unstableOnFocus: function unstableOnFocus() {
      return setSelectedCell();
    },
    __unstableOnSplitAtEnd: function __unstableOnSplitAtEnd() {
      return insertBlocksAfter(createBlock('core/paragraph'));
    }
  }), isEmpty && createElement(Placeholder, {
    label: __('Table'),
    icon: createElement(BlockIcon, {
      icon: icon,
      showColors: true
    }),
    instructions: __('Insert a table for sharing data.')
  }, createElement("form", {
    className: "blocks-table__placeholder-form",
    onSubmit: onCreateTable
  }, createElement(TextControl, {
    type: "number",
    label: __('Column count'),
    value: initialColumnCount,
    onChange: onChangeInitialColumnCount,
    min: "1",
    className: "blocks-table__placeholder-input"
  }), createElement(TextControl, {
    type: "number",
    label: __('Row count'),
    value: initialRowCount,
    onChange: onChangeInitialRowCount,
    min: "1",
    className: "blocks-table__placeholder-input"
  }), createElement(Button, {
    className: "blocks-table__placeholder-button",
    isPrimary: true,
    type: "submit"
  }, __('Create Table')))));
}

export default withCustomBackgroundColors('backgroundColor')(TableEdit);
//# sourceMappingURL=edit.js.map