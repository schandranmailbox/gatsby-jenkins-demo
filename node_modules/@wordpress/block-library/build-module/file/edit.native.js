import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import { createElement } from "@wordpress/element";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * External dependencies
 */
import { View, Clipboard, TouchableWithoutFeedback, Text } from 'react-native';
/**
 * WordPress dependencies
 */

import { requestImageFailedRetryDialog, requestImageUploadCancelDialog, mediaUploadSync } from '@wordpress/react-native-bridge';
import { BlockIcon, MediaPlaceholder, MediaUploadProgress, RichText, PlainText, BlockControls, MediaUpload, InspectorControls, MEDIA_TYPE_ANY } from '@wordpress/block-editor';
import { ToolbarButton, ToolbarGroup, PanelBody, ToggleControl, TextControl, SelectControl, Icon } from '@wordpress/components';
import { file as icon, replace, button, external, link, warning } from '@wordpress/icons';
import { Component } from '@wordpress/element';
import { __, _x } from '@wordpress/i18n';
import { compose, withPreferredColorScheme } from '@wordpress/compose';
import { withDispatch, withSelect } from '@wordpress/data';
import { getProtocol } from '@wordpress/url';
/**
 * Internal dependencies
 */

import styles from './style.scss';
var URL_COPIED_NOTIFICATION_DURATION_MS = 1500;
var MIN_WIDTH = 40;
export var FileEdit = /*#__PURE__*/function (_Component) {
  _inherits(FileEdit, _Component);

  var _super = _createSuper(FileEdit);

  function FileEdit(props) {
    var _this;

    _classCallCheck(this, FileEdit);

    _this = _super.call(this, props);
    _this.state = {
      isUploadInProgress: false,
      isSidebarLinkSettings: false,
      placeholderTextWidth: 0,
      maxWidth: 0
    };
    _this.timerRef = null;
    _this.onLayout = _this.onLayout.bind(_assertThisInitialized(_this));
    _this.onSelectFile = _this.onSelectFile.bind(_assertThisInitialized(_this));
    _this.onChangeFileName = _this.onChangeFileName.bind(_assertThisInitialized(_this));
    _this.onChangeDownloadButtonText = _this.onChangeDownloadButtonText.bind(_assertThisInitialized(_this));
    _this.updateMediaProgress = _this.updateMediaProgress.bind(_assertThisInitialized(_this));
    _this.finishMediaUploadWithSuccess = _this.finishMediaUploadWithSuccess.bind(_assertThisInitialized(_this));
    _this.finishMediaUploadWithFailure = _this.finishMediaUploadWithFailure.bind(_assertThisInitialized(_this));
    _this.getFileComponent = _this.getFileComponent.bind(_assertThisInitialized(_this));
    _this.onChangeDownloadButtonVisibility = _this.onChangeDownloadButtonVisibility.bind(_assertThisInitialized(_this));
    _this.onCopyURL = _this.onCopyURL.bind(_assertThisInitialized(_this));
    _this.onChangeOpenInNewWindow = _this.onChangeOpenInNewWindow.bind(_assertThisInitialized(_this));
    _this.onChangeLinkDestinationOption = _this.onChangeLinkDestinationOption.bind(_assertThisInitialized(_this));
    _this.onShowLinkSettings = _this.onShowLinkSettings.bind(_assertThisInitialized(_this));
    _this.onFilePressed = _this.onFilePressed.bind(_assertThisInitialized(_this));
    _this.mediaUploadStateReset = _this.mediaUploadStateReset.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(FileEdit, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props = this.props,
          attributes = _this$props.attributes,
          setAttributes = _this$props.setAttributes;
      var downloadButtonText = attributes.downloadButtonText;

      if (downloadButtonText === undefined || downloadButtonText === '') {
        setAttributes({
          downloadButtonText: _x('Download', 'button label')
        });
      }

      if (attributes.id && attributes.url && getProtocol(attributes.url) === 'file:') {
        mediaUploadSync();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      clearTimeout(this.timerRef);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.isSidebarOpened && !this.props.isSidebarOpened && this.state.isSidebarLinkSettings) {
        this.setState({
          isSidebarLinkSettings: false
        });
      }
    }
  }, {
    key: "onSelectFile",
    value: function onSelectFile(media) {
      this.props.setAttributes({
        href: media.url,
        fileName: media.title,
        textLinkHref: media.url,
        id: media.id
      });
    }
  }, {
    key: "onChangeFileName",
    value: function onChangeFileName(fileName) {
      this.props.setAttributes({
        fileName: fileName
      });
    }
  }, {
    key: "onChangeDownloadButtonText",
    value: function onChangeDownloadButtonText(downloadButtonText) {
      this.props.setAttributes({
        downloadButtonText: downloadButtonText
      });
    }
  }, {
    key: "onChangeDownloadButtonVisibility",
    value: function onChangeDownloadButtonVisibility(showDownloadButton) {
      this.props.setAttributes({
        showDownloadButton: showDownloadButton
      });
    }
  }, {
    key: "onChangeLinkDestinationOption",
    value: function onChangeLinkDestinationOption(newHref) {
      // Choose Media File or Attachment Page (when file is in Media Library)
      this.props.setAttributes({
        textLinkHref: newHref
      });
    }
  }, {
    key: "onCopyURL",
    value: function onCopyURL() {
      var _this2 = this;

      if (this.state.isUrlCopied) {
        return;
      }

      var href = this.props.attributes.href;
      Clipboard.setString(href);
      this.setState({
        isUrlCopied: true
      });
      this.timerRef = setTimeout(function () {
        _this2.setState({
          isUrlCopied: false
        });
      }, URL_COPIED_NOTIFICATION_DURATION_MS);
    }
  }, {
    key: "onChangeOpenInNewWindow",
    value: function onChangeOpenInNewWindow(newValue) {
      this.props.setAttributes({
        textLinkTarget: newValue ? '_blank' : false
      });
    }
  }, {
    key: "updateMediaProgress",
    value: function updateMediaProgress(payload) {
      var setAttributes = this.props.setAttributes;

      if (payload.mediaUrl) {
        setAttributes({
          url: payload.mediaUrl
        });
      }

      if (!this.state.isUploadInProgress) {
        this.setState({
          isUploadInProgress: true
        });
      }
    }
  }, {
    key: "finishMediaUploadWithSuccess",
    value: function finishMediaUploadWithSuccess(payload) {
      var setAttributes = this.props.setAttributes;
      setAttributes({
        href: payload.mediaUrl,
        id: payload.mediaServerId,
        textLinkHref: payload.mediaUrl
      });
      this.setState({
        isUploadInProgress: false
      });
    }
  }, {
    key: "finishMediaUploadWithFailure",
    value: function finishMediaUploadWithFailure(payload) {
      this.props.setAttributes({
        id: payload.mediaId
      });
      this.setState({
        isUploadInProgress: false
      });
    }
  }, {
    key: "mediaUploadStateReset",
    value: function mediaUploadStateReset() {
      var setAttributes = this.props.setAttributes;
      setAttributes({
        id: null,
        href: null,
        textLinkHref: null,
        fileName: null
      });
      this.setState({
        isUploadInProgress: false
      });
    }
  }, {
    key: "onShowLinkSettings",
    value: function onShowLinkSettings() {
      this.setState({
        isSidebarLinkSettings: true
      }, this.props.openSidebar);
    }
  }, {
    key: "getToolbarEditButton",
    value: function getToolbarEditButton(open) {
      return createElement(BlockControls, null, createElement(ToolbarGroup, null, createElement(ToolbarButton, {
        title: __('Edit file'),
        icon: replace,
        onClick: open
      }), createElement(ToolbarButton, {
        title: __('Link To'),
        icon: link,
        onClick: this.onShowLinkSettings
      })));
    }
  }, {
    key: "getInspectorControls",
    value: function getInspectorControls(_ref, media, isUploadInProgress, isUploadFailed) {
      var showDownloadButton = _ref.showDownloadButton,
          textLinkTarget = _ref.textLinkTarget,
          href = _ref.href,
          textLinkHref = _ref.textLinkHref;
      var linkDestinationOptions = [{
        value: href,
        label: __('URL')
      }];
      var attachmentPage = media && media.link;
      var isSidebarLinkSettings = this.state.isSidebarLinkSettings;

      if (attachmentPage) {
        linkDestinationOptions = [{
          value: href,
          label: __('Media file')
        }, {
          value: attachmentPage,
          label: __('Attachment page')
        }];
      }

      var actionButtonStyle = this.props.getStylesFromColorScheme(styles.actionButton, styles.actionButtonDark);
      var isCopyUrlDisabled = isUploadFailed || isUploadInProgress;
      var dimmedActionButtonStyle = this.props.getStylesFromColorScheme(styles.dimmedActionButton, styles.dimmedActionButtonDark);
      var finalButtonStyle = isCopyUrlDisabled ? dimmedActionButtonStyle : actionButtonStyle;
      return createElement(InspectorControls, null, isSidebarLinkSettings || createElement(PanelBody, {
        title: __('File block settings')
      }), createElement(PanelBody, null, createElement(SelectControl, {
        icon: link,
        label: __('Link to'),
        value: textLinkHref,
        onChange: this.onChangeLinkDestinationOption,
        options: linkDestinationOptions
      }), createElement(ToggleControl, {
        icon: external,
        label: __('Open in new tab'),
        checked: textLinkTarget === '_blank',
        onChange: this.onChangeOpenInNewWindow
      }), !isSidebarLinkSettings && createElement(ToggleControl, {
        icon: button,
        label: __('Show download button'),
        checked: showDownloadButton,
        onChange: this.onChangeDownloadButtonVisibility
      }), createElement(TextControl, {
        disabled: isCopyUrlDisabled,
        label: this.state.isUrlCopied ? __('Copied!') : __('Copy file URL'),
        labelStyle: this.state.isUrlCopied || finalButtonStyle,
        onPress: this.onCopyURL
      })));
    }
  }, {
    key: "getStyleForAlignment",
    value: function getStyleForAlignment(align) {
      var getFlexAlign = function getFlexAlign(alignment) {
        switch (alignment) {
          case 'right':
            return 'flex-end';

          case 'center':
            return 'center';

          default:
            return 'flex-start';
        }
      };

      return {
        alignSelf: getFlexAlign(align)
      };
    }
  }, {
    key: "getTextAlignmentForAlignment",
    value: function getTextAlignmentForAlignment(align) {
      switch (align) {
        case 'right':
          return 'right';

        case 'center':
          return 'center';

        default:
          return 'left';
      }
    }
  }, {
    key: "onFilePressed",
    value: function onFilePressed() {
      var attributes = this.props.attributes;

      if (this.state.isUploadInProgress) {
        requestImageUploadCancelDialog(attributes.id);
      } else if (attributes.id && getProtocol(attributes.href) === 'file:') {
        requestImageFailedRetryDialog(attributes.id);
      }
    }
  }, {
    key: "onLayout",
    value: function onLayout(_ref2) {
      var nativeEvent = _ref2.nativeEvent;
      var width = nativeEvent.layout.width;
      var _styles$defaultButton = styles.defaultButton,
          paddingLeft = _styles$defaultButton.paddingLeft,
          paddingRight = _styles$defaultButton.paddingRight;
      this.setState({
        maxWidth: width - (paddingLeft + paddingRight)
      });
    } // Render `Text` with `placeholderText` styled as a placeholder
    // to calculate its width which then is set as a `minWidth`
    // This should be fixed on RNAztec level. In the mean time,
    // We use the same strategy implemented in Button block

  }, {
    key: "getPlaceholderWidth",
    value: function getPlaceholderWidth(placeholderText) {
      var _this3 = this;

      var _this$state = this.state,
          maxWidth = _this$state.maxWidth,
          placeholderTextWidth = _this$state.placeholderTextWidth;
      return createElement(Text, {
        style: styles.placeholder,
        onTextLayout: function onTextLayout(_ref3) {
          var nativeEvent = _ref3.nativeEvent;
          var textWidth = nativeEvent.lines[0] && nativeEvent.lines[0].width;

          if (textWidth && textWidth !== placeholderTextWidth) {
            _this3.setState({
              placeholderTextWidth: Math.min(textWidth, maxWidth)
            });
          }
        }
      }, placeholderText);
    }
  }, {
    key: "getFileComponent",
    value: function getFileComponent(openMediaOptions, getMediaOptions) {
      var _this4 = this;

      var _this$props2 = this.props,
          attributes = _this$props2.attributes,
          media = _this$props2.media,
          isSelected = _this$props2.isSelected;
      var _this$state2 = this.state,
          isButtonFocused = _this$state2.isButtonFocused,
          placeholderTextWidth = _this$state2.placeholderTextWidth;
      var fileName = attributes.fileName,
          downloadButtonText = attributes.downloadButtonText,
          id = attributes.id,
          showDownloadButton = attributes.showDownloadButton,
          align = attributes.align;
      var minWidth = isButtonFocused || !isButtonFocused && downloadButtonText && downloadButtonText !== '' ? MIN_WIDTH : placeholderTextWidth;
      var placeholderText = isButtonFocused || !isButtonFocused && downloadButtonText && downloadButtonText !== '' ? '' : __('Add textâ€¦');
      return createElement(MediaUploadProgress, {
        mediaId: id,
        onUpdateMediaProgress: this.updateMediaProgress,
        onFinishMediaUploadWithSuccess: this.finishMediaUploadWithSuccess,
        onFinishMediaUploadWithFailure: this.finishMediaUploadWithFailure,
        onMediaUploadStateReset: this.mediaUploadStateReset,
        renderContent: function renderContent(_ref4) {
          var isUploadInProgress = _ref4.isUploadInProgress,
              isUploadFailed = _ref4.isUploadFailed;
          var dimmedStyle = (_this4.state.isUploadInProgress || isUploadFailed) && styles.disabledButton;
          var finalButtonStyle = [styles.defaultButton, dimmedStyle];
          var errorIconStyle = Object.assign({}, styles.errorIcon, styles.uploadFailed);
          return createElement(TouchableWithoutFeedback, {
            accessible: !isSelected,
            onPress: _this4.onFilePressed,
            onLongPress: openMediaOptions,
            disabled: !isSelected
          }, createElement(View, {
            onLayout: _this4.onLayout
          }, _this4.getPlaceholderWidth(placeholderText), isUploadInProgress || _this4.getToolbarEditButton(openMediaOptions), getMediaOptions(), isSelected && _this4.getInspectorControls(attributes, media, isUploadInProgress, isUploadFailed), createElement(View, {
            style: styles.container
          }, createElement(RichText, {
            withoutInteractiveFormatting: true,
            __unstableMobileNoFocusOnMount: true,
            onChange: _this4.onChangeFileName,
            placeholder: __('File name'),
            rootTagsToEliminate: ['p'],
            tagName: "p",
            underlineColorAndroid: "transparent",
            value: fileName,
            deleteEnter: true,
            textAlign: _this4.getTextAlignmentForAlignment(align)
          }), isUploadFailed && createElement(View, {
            style: styles.errorContainer
          }, createElement(Icon, {
            icon: warning,
            style: errorIconStyle
          }), createElement(PlainText, {
            editable: false,
            value: __('Error'),
            style: styles.uploadFailed
          }))), showDownloadButton && _this4.state.maxWidth > 0 && createElement(View, {
            style: [finalButtonStyle, _this4.getStyleForAlignment(align)]
          }, createElement(RichText, {
            withoutInteractiveFormatting: true,
            __unstableMobileNoFocusOnMount: true,
            rootTagsToEliminate: ['p'],
            tagName: "p",
            textAlign: "center",
            minWidth: minWidth,
            maxWidth: _this4.state.maxWidth,
            deleteEnter: true,
            style: styles.buttonText,
            value: downloadButtonText,
            placeholder: placeholderText,
            unstableOnFocus: function unstableOnFocus() {
              return _this4.setState({
                isButtonFocused: true
              });
            },
            onBlur: function onBlur() {
              return _this4.setState({
                isButtonFocused: false
              });
            },
            selectionColor: styles.buttonText.color,
            placeholderTextColor: styles.placeholderTextColor.color,
            underlineColorAndroid: "transparent",
            onChange: _this4.onChangeDownloadButtonText
          }))));
        }
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this5 = this;

      var attributes = this.props.attributes;
      var href = attributes.href;

      if (!href) {
        return createElement(MediaPlaceholder, {
          icon: createElement(BlockIcon, {
            icon: icon
          }),
          labels: {
            title: __('File'),
            instructions: __('CHOOSE A FILE')
          },
          onSelect: this.onSelectFile,
          onFocus: this.props.onFocus,
          allowedTypes: [MEDIA_TYPE_ANY]
        });
      }

      return createElement(MediaUpload, {
        allowedTypes: [MEDIA_TYPE_ANY],
        isReplacingMedia: true,
        onSelect: this.onSelectFile,
        render: function render(_ref5) {
          var open = _ref5.open,
              getMediaOptions = _ref5.getMediaOptions;
          return _this5.getFileComponent(open, getMediaOptions);
        }
      });
    }
  }]);

  return FileEdit;
}(Component);
export default compose([withSelect(function (select, props) {
  var attributes = props.attributes;
  var id = attributes.id,
      href = attributes.href;

  var _select = select('core/edit-post'),
      isEditorSidebarOpened = _select.isEditorSidebarOpened;

  var isNotFileHref = id && getProtocol(href) !== 'file:';
  return {
    media: isNotFileHref ? select('core').getMedia(id) : undefined,
    isSidebarOpened: isEditorSidebarOpened()
  };
}), withDispatch(function (dispatch) {
  var _dispatch = dispatch('core/edit-post'),
      openGeneralSidebar = _dispatch.openGeneralSidebar;

  return {
    openSidebar: function openSidebar() {
      return openGeneralSidebar('edit-post/block');
    }
  };
}), withPreferredColorScheme])(FileEdit);
//# sourceMappingURL=edit.native.js.map