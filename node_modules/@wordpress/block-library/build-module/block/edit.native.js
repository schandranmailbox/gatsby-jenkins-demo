import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement, Fragment } from "@wordpress/element";

/**
 * External dependencies
 */
import { ActivityIndicator, Platform, Text, TouchableWithoutFeedback, View } from 'react-native';
/**
 * WordPress dependencies
 */

import { useEffect, useRef, useState } from '@wordpress/element';
import { useEntityBlockEditor } from '@wordpress/core-data';
import { BottomSheet, Icon, Disabled } from '@wordpress/components';
import { useSelect, useDispatch } from '@wordpress/data';
import { __ } from '@wordpress/i18n';
import { BlockEditorProvider, BlockList } from '@wordpress/block-editor';
import { usePreferredColorSchemeStyle } from '@wordpress/compose';
import { help } from '@wordpress/icons';
import { requestUnsupportedBlockFallback, sendActionButtonPressedAction, actionButtons } from '@wordpress/react-native-bridge';
import { store as reusableBlocksStore } from '@wordpress/reusable-blocks';
import { applyFilters } from '@wordpress/hooks';
/**
 * Internal dependencies
 */

import styles from './editor.scss';
import EditTitle from './edit-title';
export default function ReusableBlockEdit(_ref) {
  var ref = _ref.attributes.ref,
      clientId = _ref.clientId,
      isSelected = _ref.isSelected;
  var recordArgs = ['postType', 'wp_block', ref];

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      showHelp = _useState2[0],
      setShowHelp = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      sendFallbackMessage = _useState4[0],
      setSendFallbackMessage = _useState4[1];

  var _useState5 = useState(false),
      _useState6 = _slicedToArray(_useState5, 2),
      sendButtonPressMessage = _useState6[0],
      setSendButtonPressMessage = _useState6[1];

  var timeoutId = useRef();
  var infoTextStyle = usePreferredColorSchemeStyle(styles.infoText, styles.infoTextDark);
  var infoTitleStyle = usePreferredColorSchemeStyle(styles.infoTitle, styles.infoTitleDark);
  var infoSheetIconStyle = usePreferredColorSchemeStyle(styles.infoSheetIcon, styles.infoSheetIconDark);
  var actionButtonStyle = usePreferredColorSchemeStyle(styles.actionButton, styles.actionButtonDark);
  var spinnerStyle = usePreferredColorSchemeStyle(styles.spinner, styles.spinnerDark);

  var _useSelect = useSelect(function (select) {
    var _select2, _select3;

    var _select = select('core/block-editor'),
        getSettings = _select.getSettings;

    return {
      reusableBlock: (_select2 = select('core')).getEditedEntityRecord.apply(_select2, recordArgs),
      hasResolved: select('core').hasFinishedResolution('getEditedEntityRecord', recordArgs),
      isSaving: (_select3 = select('core')).isSavingEntityRecord.apply(_select3, recordArgs),
      canUserUpdate: select('core').canUser('update', 'blocks', ref),
      isEditing: select(reusableBlocksStore).__experimentalIsEditingReusableBlock(clientId),
      settings: getSettings(),
      isUnsupportedBlockEditorSupported: getSettings('capabilities').unsupportedBlockEditor === true,
      canEnableUnsupportedBlockEditor: getSettings('capabilities').canEnableUnsupportedBlockEditor === true
    };
  }, [ref, clientId]),
      reusableBlock = _useSelect.reusableBlock,
      hasResolved = _useSelect.hasResolved,
      isEditing = _useSelect.isEditing,
      settings = _useSelect.settings,
      isUnsupportedBlockEditorSupported = _useSelect.isUnsupportedBlockEditorSupported,
      canEnableUnsupportedBlockEditor = _useSelect.canEnableUnsupportedBlockEditor;

  var _useDispatch = useDispatch('core'),
      invalidateResolution = _useDispatch.invalidateResolution;

  var _useEntityBlockEditor = useEntityBlockEditor('postType', 'wp_block', {
    id: ref
  }),
      _useEntityBlockEditor2 = _slicedToArray(_useEntityBlockEditor, 3),
      blocks = _useEntityBlockEditor2[0],
      onInput = _useEntityBlockEditor2[1],
      onChange = _useEntityBlockEditor2[2];

  useEffect(function () {
    return function () {
      clearTimeout(timeoutId.current);
      /**
       * Invalidate entity record upon unmount to keep the reusable block updated
       * in case it's modified through UBE
       */

      invalidateResolution('getEntityRecord', recordArgs);
    };
  }, []);

  function openSheet() {
    setShowHelp(true);
  }

  function closeSheet() {
    setShowHelp(false);
  }

  function requestFallback() {
    closeSheet();

    if (canEnableUnsupportedBlockEditor && !isUnsupportedBlockEditorSupported) {
      setSendButtonPressMessage(true);
    } else {
      setSendFallbackMessage(true);
    }
  }

  function renderSheet() {
    var infoTitle = Platform.OS === 'android' ? __("Reusable blocks aren't editable on WordPress for Android") : __("Reusable blocks aren't editable on WordPress for iOS");
    var reusableBlockActionButton = applyFilters('native.reusable_block_action_button', __('Edit using web editor'));
    return createElement(BottomSheet, {
      isVisible: showHelp,
      hideHeader: true,
      onClose: closeSheet,
      onModalHide: function onModalHide() {
        if (sendFallbackMessage) {
          // On iOS, onModalHide is called when the controller is still part of the hierarchy.
          // A small delay will ensure that the controller has already been removed.
          timeoutId.current = setTimeout(function () {
            requestUnsupportedBlockFallback("<!-- wp:block {\"ref\":".concat(reusableBlock.id, "} /-->"), clientId, reusableBlock.name, reusableBlock.title);
            invalidateResolution('getEntityRecord', recordArgs);
          }, 100);
          setSendFallbackMessage(false);
        } else if (sendButtonPressMessage) {
          timeoutId.current = setTimeout(function () {
            sendActionButtonPressedAction(actionButtons.missingBlockAlertActionButton);
          }, 100);
          setSendButtonPressMessage(false);
        }
      }
    }, createElement(View, {
      style: styles.infoContainer
    }, createElement(Icon, {
      icon: help,
      color: infoSheetIconStyle.color,
      size: styles.infoSheetIcon.size
    }), createElement(Text, {
      style: [infoTextStyle, infoTitleStyle]
    }, infoTitle)), (isUnsupportedBlockEditorSupported || canEnableUnsupportedBlockEditor) && createElement(Fragment, null, createElement(BottomSheet.Cell, {
      label: reusableBlockActionButton,
      separatorType: "topFullWidth",
      onPress: requestFallback,
      labelStyle: actionButtonStyle
    }), createElement(BottomSheet.Cell, {
      label: __('Dismiss'),
      separatorType: "topFullWidth",
      onPress: closeSheet,
      labelStyle: actionButtonStyle
    })));
  }

  if (!hasResolved) {
    return createElement(View, {
      style: spinnerStyle
    }, createElement(ActivityIndicator, {
      animating: true
    }));
  }

  if (!reusableBlock) {
    return createElement(Text, null, __('Block has been deleted or is unavailable.'));
  }

  var title = reusableBlock.title;
  var element = createElement(BlockEditorProvider, {
    settings: settings,
    value: blocks,
    onChange: onChange,
    onInput: onInput
  }, createElement(BlockList, {
    withFooter: false,
    marginHorizontal: 0
  }));

  if (!isEditing) {
    element = createElement(Disabled, null, element);
  }

  return createElement(TouchableWithoutFeedback, {
    disabled: !isSelected,
    accessibilityLabel: __('Help button'),
    accessibilityRole: 'button',
    accessibilityHint: __('Tap here to show help'),
    onPress: openSheet
  }, createElement(View, null, isSelected && createElement(EditTitle, {
    title: title
  }), element, renderSheet()));
}
//# sourceMappingURL=edit.native.js.map