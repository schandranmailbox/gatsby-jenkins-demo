import _extends from "@babel/runtime/helpers/esm/extends";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement, Fragment } from "@wordpress/element";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * External dependencies
 */
import { every, filter, find, forEach, get, isEmpty, map, reduce, some, toString } from 'lodash';
/**
 * WordPress dependencies
 */

import { compose } from '@wordpress/compose';
import { PanelBody, SelectControl, ToggleControl, withNotices, RangeControl } from '@wordpress/components';
import { MediaPlaceholder, InspectorControls, useBlockProps } from '@wordpress/block-editor';
import { Platform, useEffect, useState, useMemo } from '@wordpress/element';
import { __ } from '@wordpress/i18n';
import { getBlobByURL, isBlobURL, revokeBlobURL } from '@wordpress/blob';
import { useDispatch, withSelect } from '@wordpress/data';
import { withViewportMatch } from '@wordpress/viewport';
import { View } from '@wordpress/primitives';
/**
 * Internal dependencies
 */

import { sharedIcon } from './shared-icon';
import { defaultColumnsNumber, pickRelevantMediaFiles } from './shared';
import Gallery from './gallery';
import { LINK_DESTINATION_ATTACHMENT, LINK_DESTINATION_MEDIA, LINK_DESTINATION_NONE } from './constants';
var MAX_COLUMNS = 8;
var linkOptions = [{
  value: LINK_DESTINATION_ATTACHMENT,
  label: __('Attachment Page')
}, {
  value: LINK_DESTINATION_MEDIA,
  label: __('Media File')
}, {
  value: LINK_DESTINATION_NONE,
  label: __('None')
}];
var ALLOWED_MEDIA_TYPES = ['image'];
var PLACEHOLDER_TEXT = Platform.select({
  web: __('Drag images, upload new ones or select files from your library.'),
  native: __('ADD MEDIA')
});
var MOBILE_CONTROL_PROPS_RANGE_CONTROL = Platform.select({
  web: {},
  native: {
    type: 'stepper'
  }
});

function GalleryEdit(props) {
  var attributes = props.attributes,
      isSelected = props.isSelected,
      noticeUI = props.noticeUI,
      noticeOperations = props.noticeOperations,
      mediaUpload = props.mediaUpload,
      imageSizes = props.imageSizes,
      resizedImages = props.resizedImages,
      onFocus = props.onFocus;
  var _attributes$columns = attributes.columns,
      columns = _attributes$columns === void 0 ? defaultColumnsNumber(attributes) : _attributes$columns,
      imageCrop = attributes.imageCrop,
      images = attributes.images,
      linkTo = attributes.linkTo,
      sizeSlug = attributes.sizeSlug;

  var _useState = useState(),
      _useState2 = _slicedToArray(_useState, 2),
      selectedImage = _useState2[0],
      setSelectedImage = _useState2[1];

  var _useState3 = useState(),
      _useState4 = _slicedToArray(_useState3, 2),
      attachmentCaptions = _useState4[0],
      setAttachmentCaptions = _useState4[1];

  var _useDispatch = useDispatch('core/block-editor'),
      __unstableMarkNextChangeAsNotPersistent = _useDispatch.__unstableMarkNextChangeAsNotPersistent;

  function setAttributes(newAttrs) {
    if (newAttrs.ids) {
      throw new Error('The "ids" attribute should not be changed directly. It is managed automatically when "images" attribute changes');
    }

    if (newAttrs.images) {
      newAttrs = _objectSpread(_objectSpread({}, newAttrs), {}, {
        // Unlike images[ n ].id which is a string, always ensure the
        // ids array contains numbers as per its attribute type.
        ids: map(newAttrs.images, function (_ref) {
          var id = _ref.id;
          return parseInt(id, 10);
        })
      });
    }

    props.setAttributes(newAttrs);
  }

  function onSelectImage(index) {
    return function () {
      setSelectedImage(index);
    };
  }

  function onDeselectImage() {
    return function () {
      setSelectedImage();
    };
  }

  function onMove(oldIndex, newIndex) {
    var newImages = _toConsumableArray(images);

    newImages.splice(newIndex, 1, images[oldIndex]);
    newImages.splice(oldIndex, 1, images[newIndex]);
    setSelectedImage(newIndex);
    setAttributes({
      images: newImages
    });
  }

  function onMoveForward(oldIndex) {
    return function () {
      if (oldIndex === images.length - 1) {
        return;
      }

      onMove(oldIndex, oldIndex + 1);
    };
  }

  function onMoveBackward(oldIndex) {
    return function () {
      if (oldIndex === 0) {
        return;
      }

      onMove(oldIndex, oldIndex - 1);
    };
  }

  function onRemoveImage(index) {
    return function () {
      var newImages = filter(images, function (img, i) {
        return index !== i;
      });
      setSelectedImage();
      setAttributes({
        images: newImages,
        columns: attributes.columns ? Math.min(newImages.length, attributes.columns) : attributes.columns
      });
    };
  }

  function selectCaption(newImage) {
    // The image id in both the images and attachmentCaptions arrays is a
    // string, so ensure comparison works correctly by converting the
    // newImage.id to a string.
    var newImageId = toString(newImage.id);
    var currentImage = find(images, {
      id: newImageId
    });
    var currentImageCaption = currentImage ? currentImage.caption : newImage.caption;

    if (!attachmentCaptions) {
      return currentImageCaption;
    }

    var attachment = find(attachmentCaptions, {
      id: newImageId
    }); // if the attachment caption is updated

    if (attachment && attachment.caption !== newImage.caption) {
      return newImage.caption;
    }

    return currentImageCaption;
  }

  function onSelectImages(newImages) {
    setAttachmentCaptions(newImages.map(function (newImage) {
      return {
        // Store the attachmentCaption id as a string for consistency
        // with the type of the id in the images attribute.
        id: toString(newImage.id),
        caption: newImage.caption
      };
    }));
    setAttributes({
      images: newImages.map(function (newImage) {
        return _objectSpread(_objectSpread({}, pickRelevantMediaFiles(newImage, sizeSlug)), {}, {
          caption: selectCaption(newImage, images, attachmentCaptions),
          // The id value is stored in a data attribute, so when the
          // block is parsed it's converted to a string. Converting
          // to a string here ensures it's type is consistent.
          id: toString(newImage.id)
        });
      }),
      columns: attributes.columns ? Math.min(newImages.length, attributes.columns) : attributes.columns
    });
  }

  function onUploadError(message) {
    noticeOperations.removeAllNotices();
    noticeOperations.createErrorNotice(message);
  }

  function setLinkTo(value) {
    setAttributes({
      linkTo: value
    });
  }

  function setColumnsNumber(value) {
    setAttributes({
      columns: value
    });
  }

  function toggleImageCrop() {
    setAttributes({
      imageCrop: !imageCrop
    });
  }

  function getImageCropHelp(checked) {
    return checked ? __('Thumbnails are cropped to align.') : __('Thumbnails are not cropped.');
  }

  function onFocusGalleryCaption() {
    setSelectedImage();
  }

  function setImageAttributes(index, newAttributes) {
    if (!images[index]) {
      return;
    }

    setAttributes({
      images: [].concat(_toConsumableArray(images.slice(0, index)), [_objectSpread(_objectSpread({}, images[index]), newAttributes)], _toConsumableArray(images.slice(index + 1)))
    });
  }

  function getImagesSizeOptions() {
    return map(filter(imageSizes, function (_ref2) {
      var slug = _ref2.slug;
      return some(resizedImages, function (sizes) {
        return sizes[slug];
      });
    }), function (_ref3) {
      var name = _ref3.name,
          slug = _ref3.slug;
      return {
        value: slug,
        label: name
      };
    });
  }

  function updateImagesSize(newSizeSlug) {
    var updatedImages = map(images, function (image) {
      if (!image.id) {
        return image;
      }

      var url = get(resizedImages, [parseInt(image.id, 10), newSizeSlug]);
      return _objectSpread(_objectSpread({}, image), url && {
        url: url
      });
    });
    setAttributes({
      images: updatedImages,
      sizeSlug: newSizeSlug
    });
  }

  useEffect(function () {
    if (Platform.OS === 'web' && images && images.length > 0 && every(images, function (_ref4) {
      var url = _ref4.url;
      return isBlobURL(url);
    })) {
      var filesList = map(images, function (_ref5) {
        var url = _ref5.url;
        return getBlobByURL(url);
      });
      forEach(images, function (_ref6) {
        var url = _ref6.url;
        return revokeBlobURL(url);
      });
      mediaUpload({
        filesList: filesList,
        onFileChange: onSelectImages,
        allowedTypes: ['image']
      });
    }
  }, []);
  useEffect(function () {
    // Deselect images when deselecting the block
    if (!isSelected) {
      setSelectedImage();
    }
  }, [isSelected]);
  useEffect(function () {
    // linkTo attribute must be saved so blocks don't break when changing
    // image_default_link_type in options.php
    if (!linkTo) {
      var _window, _window$wp, _window$wp$media, _window$wp$media$view, _window$wp$media$view2, _window$wp$media$view3;

      __unstableMarkNextChangeAsNotPersistent();

      setAttributes({
        linkTo: ((_window = window) === null || _window === void 0 ? void 0 : (_window$wp = _window.wp) === null || _window$wp === void 0 ? void 0 : (_window$wp$media = _window$wp.media) === null || _window$wp$media === void 0 ? void 0 : (_window$wp$media$view = _window$wp$media.view) === null || _window$wp$media$view === void 0 ? void 0 : (_window$wp$media$view2 = _window$wp$media$view.settings) === null || _window$wp$media$view2 === void 0 ? void 0 : (_window$wp$media$view3 = _window$wp$media$view2.defaultProps) === null || _window$wp$media$view3 === void 0 ? void 0 : _window$wp$media$view3.link) || LINK_DESTINATION_NONE
      });
    }
  }, [linkTo]);
  var hasImages = !!images.length;
  var mediaPlaceholder = createElement(MediaPlaceholder, {
    addToGallery: hasImages,
    isAppender: hasImages,
    disableMediaButtons: hasImages && !isSelected,
    icon: !hasImages && sharedIcon,
    labels: {
      title: !hasImages && __('Gallery'),
      instructions: !hasImages && PLACEHOLDER_TEXT
    },
    onSelect: onSelectImages,
    accept: "image/*",
    allowedTypes: ALLOWED_MEDIA_TYPES,
    multiple: true,
    value: images,
    onError: onUploadError,
    notices: hasImages ? undefined : noticeUI,
    onFocus: onFocus
  });
  var blockProps = useBlockProps();

  if (!hasImages) {
    return createElement(View, blockProps, mediaPlaceholder);
  }

  var imageSizeOptions = getImagesSizeOptions();
  var shouldShowSizeOptions = hasImages && !isEmpty(imageSizeOptions);
  return createElement(Fragment, null, createElement(InspectorControls, null, createElement(PanelBody, {
    title: __('Gallery settings')
  }, images.length > 1 && createElement(RangeControl, _extends({
    label: __('Columns'),
    value: columns,
    onChange: setColumnsNumber,
    min: 1,
    max: Math.min(MAX_COLUMNS, images.length)
  }, MOBILE_CONTROL_PROPS_RANGE_CONTROL, {
    required: true
  })), createElement(ToggleControl, {
    label: __('Crop images'),
    checked: !!imageCrop,
    onChange: toggleImageCrop,
    help: getImageCropHelp
  }), createElement(SelectControl, {
    label: __('Link to'),
    value: linkTo,
    onChange: setLinkTo,
    options: linkOptions
  }), shouldShowSizeOptions && createElement(SelectControl, {
    label: __('Image size'),
    value: sizeSlug,
    options: imageSizeOptions,
    onChange: updateImagesSize
  }))), noticeUI, createElement(Gallery, _extends({}, props, {
    selectedImage: selectedImage,
    mediaPlaceholder: mediaPlaceholder,
    onMoveBackward: onMoveBackward,
    onMoveForward: onMoveForward,
    onRemoveImage: onRemoveImage,
    onSelectImage: onSelectImage,
    onDeselectImage: onDeselectImage,
    onSetImageAttributes: setImageAttributes,
    onFocusGalleryCaption: onFocusGalleryCaption,
    blockProps: blockProps
  })));
}

export default compose([withSelect(function (select, _ref7) {
  var ids = _ref7.attributes.ids,
      isSelected = _ref7.isSelected;

  var _select = select('core'),
      getMedia = _select.getMedia;

  var _select2 = select('core/block-editor'),
      getSettings = _select2.getSettings;

  var _getSettings = getSettings(),
      imageSizes = _getSettings.imageSizes,
      mediaUpload = _getSettings.mediaUpload;

  var resizedImages = useMemo(function () {
    if (isSelected) {
      return reduce(ids, function (currentResizedImages, id) {
        if (!id) {
          return currentResizedImages;
        }

        var image = getMedia(id);
        var sizes = reduce(imageSizes, function (currentSizes, size) {
          var defaultUrl = get(image, ['sizes', size.slug, 'url']);
          var mediaDetailsUrl = get(image, ['media_details', 'sizes', size.slug, 'source_url']);
          return _objectSpread(_objectSpread({}, currentSizes), {}, _defineProperty({}, size.slug, defaultUrl || mediaDetailsUrl));
        }, {});
        return _objectSpread(_objectSpread({}, currentResizedImages), {}, _defineProperty({}, parseInt(id, 10), sizes));
      }, {});
    }

    return {};
  }, [isSelected, ids, imageSizes]);
  return {
    imageSizes: imageSizes,
    mediaUpload: mediaUpload,
    resizedImages: resizedImages
  };
}), withNotices, withViewportMatch({
  isNarrow: '< small'
})])(GalleryEdit);
//# sourceMappingURL=edit.js.map