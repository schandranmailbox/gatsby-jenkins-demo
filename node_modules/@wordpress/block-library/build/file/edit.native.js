"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FileEdit = void 0;

var _element = require("@wordpress/element");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _reactNative = require("react-native");

var _reactNativeBridge = require("@wordpress/react-native-bridge");

var _blockEditor = require("@wordpress/block-editor");

var _components = require("@wordpress/components");

var _icons = require("@wordpress/icons");

var _i18n = require("@wordpress/i18n");

var _compose = require("@wordpress/compose");

var _data = require("@wordpress/data");

var _url = require("@wordpress/url");

var _style = _interopRequireDefault(require("./style.scss"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var URL_COPIED_NOTIFICATION_DURATION_MS = 1500;
var MIN_WIDTH = 40;

var FileEdit = /*#__PURE__*/function (_Component) {
  (0, _inherits2.default)(FileEdit, _Component);

  var _super = _createSuper(FileEdit);

  function FileEdit(props) {
    var _this;

    (0, _classCallCheck2.default)(this, FileEdit);
    _this = _super.call(this, props);
    _this.state = {
      isUploadInProgress: false,
      isSidebarLinkSettings: false,
      placeholderTextWidth: 0,
      maxWidth: 0
    };
    _this.timerRef = null;
    _this.onLayout = _this.onLayout.bind((0, _assertThisInitialized2.default)(_this));
    _this.onSelectFile = _this.onSelectFile.bind((0, _assertThisInitialized2.default)(_this));
    _this.onChangeFileName = _this.onChangeFileName.bind((0, _assertThisInitialized2.default)(_this));
    _this.onChangeDownloadButtonText = _this.onChangeDownloadButtonText.bind((0, _assertThisInitialized2.default)(_this));
    _this.updateMediaProgress = _this.updateMediaProgress.bind((0, _assertThisInitialized2.default)(_this));
    _this.finishMediaUploadWithSuccess = _this.finishMediaUploadWithSuccess.bind((0, _assertThisInitialized2.default)(_this));
    _this.finishMediaUploadWithFailure = _this.finishMediaUploadWithFailure.bind((0, _assertThisInitialized2.default)(_this));
    _this.getFileComponent = _this.getFileComponent.bind((0, _assertThisInitialized2.default)(_this));
    _this.onChangeDownloadButtonVisibility = _this.onChangeDownloadButtonVisibility.bind((0, _assertThisInitialized2.default)(_this));
    _this.onCopyURL = _this.onCopyURL.bind((0, _assertThisInitialized2.default)(_this));
    _this.onChangeOpenInNewWindow = _this.onChangeOpenInNewWindow.bind((0, _assertThisInitialized2.default)(_this));
    _this.onChangeLinkDestinationOption = _this.onChangeLinkDestinationOption.bind((0, _assertThisInitialized2.default)(_this));
    _this.onShowLinkSettings = _this.onShowLinkSettings.bind((0, _assertThisInitialized2.default)(_this));
    _this.onFilePressed = _this.onFilePressed.bind((0, _assertThisInitialized2.default)(_this));
    _this.mediaUploadStateReset = _this.mediaUploadStateReset.bind((0, _assertThisInitialized2.default)(_this));
    return _this;
  }

  (0, _createClass2.default)(FileEdit, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props = this.props,
          attributes = _this$props.attributes,
          setAttributes = _this$props.setAttributes;
      var downloadButtonText = attributes.downloadButtonText;

      if (downloadButtonText === undefined || downloadButtonText === '') {
        setAttributes({
          downloadButtonText: (0, _i18n._x)('Download', 'button label')
        });
      }

      if (attributes.id && attributes.url && (0, _url.getProtocol)(attributes.url) === 'file:') {
        (0, _reactNativeBridge.mediaUploadSync)();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      clearTimeout(this.timerRef);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.isSidebarOpened && !this.props.isSidebarOpened && this.state.isSidebarLinkSettings) {
        this.setState({
          isSidebarLinkSettings: false
        });
      }
    }
  }, {
    key: "onSelectFile",
    value: function onSelectFile(media) {
      this.props.setAttributes({
        href: media.url,
        fileName: media.title,
        textLinkHref: media.url,
        id: media.id
      });
    }
  }, {
    key: "onChangeFileName",
    value: function onChangeFileName(fileName) {
      this.props.setAttributes({
        fileName: fileName
      });
    }
  }, {
    key: "onChangeDownloadButtonText",
    value: function onChangeDownloadButtonText(downloadButtonText) {
      this.props.setAttributes({
        downloadButtonText: downloadButtonText
      });
    }
  }, {
    key: "onChangeDownloadButtonVisibility",
    value: function onChangeDownloadButtonVisibility(showDownloadButton) {
      this.props.setAttributes({
        showDownloadButton: showDownloadButton
      });
    }
  }, {
    key: "onChangeLinkDestinationOption",
    value: function onChangeLinkDestinationOption(newHref) {
      // Choose Media File or Attachment Page (when file is in Media Library)
      this.props.setAttributes({
        textLinkHref: newHref
      });
    }
  }, {
    key: "onCopyURL",
    value: function onCopyURL() {
      var _this2 = this;

      if (this.state.isUrlCopied) {
        return;
      }

      var href = this.props.attributes.href;

      _reactNative.Clipboard.setString(href);

      this.setState({
        isUrlCopied: true
      });
      this.timerRef = setTimeout(function () {
        _this2.setState({
          isUrlCopied: false
        });
      }, URL_COPIED_NOTIFICATION_DURATION_MS);
    }
  }, {
    key: "onChangeOpenInNewWindow",
    value: function onChangeOpenInNewWindow(newValue) {
      this.props.setAttributes({
        textLinkTarget: newValue ? '_blank' : false
      });
    }
  }, {
    key: "updateMediaProgress",
    value: function updateMediaProgress(payload) {
      var setAttributes = this.props.setAttributes;

      if (payload.mediaUrl) {
        setAttributes({
          url: payload.mediaUrl
        });
      }

      if (!this.state.isUploadInProgress) {
        this.setState({
          isUploadInProgress: true
        });
      }
    }
  }, {
    key: "finishMediaUploadWithSuccess",
    value: function finishMediaUploadWithSuccess(payload) {
      var setAttributes = this.props.setAttributes;
      setAttributes({
        href: payload.mediaUrl,
        id: payload.mediaServerId,
        textLinkHref: payload.mediaUrl
      });
      this.setState({
        isUploadInProgress: false
      });
    }
  }, {
    key: "finishMediaUploadWithFailure",
    value: function finishMediaUploadWithFailure(payload) {
      this.props.setAttributes({
        id: payload.mediaId
      });
      this.setState({
        isUploadInProgress: false
      });
    }
  }, {
    key: "mediaUploadStateReset",
    value: function mediaUploadStateReset() {
      var setAttributes = this.props.setAttributes;
      setAttributes({
        id: null,
        href: null,
        textLinkHref: null,
        fileName: null
      });
      this.setState({
        isUploadInProgress: false
      });
    }
  }, {
    key: "onShowLinkSettings",
    value: function onShowLinkSettings() {
      this.setState({
        isSidebarLinkSettings: true
      }, this.props.openSidebar);
    }
  }, {
    key: "getToolbarEditButton",
    value: function getToolbarEditButton(open) {
      return (0, _element.createElement)(_blockEditor.BlockControls, null, (0, _element.createElement)(_components.ToolbarGroup, null, (0, _element.createElement)(_components.ToolbarButton, {
        title: (0, _i18n.__)('Edit file'),
        icon: _icons.replace,
        onClick: open
      }), (0, _element.createElement)(_components.ToolbarButton, {
        title: (0, _i18n.__)('Link To'),
        icon: _icons.link,
        onClick: this.onShowLinkSettings
      })));
    }
  }, {
    key: "getInspectorControls",
    value: function getInspectorControls(_ref, media, isUploadInProgress, isUploadFailed) {
      var showDownloadButton = _ref.showDownloadButton,
          textLinkTarget = _ref.textLinkTarget,
          href = _ref.href,
          textLinkHref = _ref.textLinkHref;
      var linkDestinationOptions = [{
        value: href,
        label: (0, _i18n.__)('URL')
      }];
      var attachmentPage = media && media.link;
      var isSidebarLinkSettings = this.state.isSidebarLinkSettings;

      if (attachmentPage) {
        linkDestinationOptions = [{
          value: href,
          label: (0, _i18n.__)('Media file')
        }, {
          value: attachmentPage,
          label: (0, _i18n.__)('Attachment page')
        }];
      }

      var actionButtonStyle = this.props.getStylesFromColorScheme(_style.default.actionButton, _style.default.actionButtonDark);
      var isCopyUrlDisabled = isUploadFailed || isUploadInProgress;
      var dimmedActionButtonStyle = this.props.getStylesFromColorScheme(_style.default.dimmedActionButton, _style.default.dimmedActionButtonDark);
      var finalButtonStyle = isCopyUrlDisabled ? dimmedActionButtonStyle : actionButtonStyle;
      return (0, _element.createElement)(_blockEditor.InspectorControls, null, isSidebarLinkSettings || (0, _element.createElement)(_components.PanelBody, {
        title: (0, _i18n.__)('File block settings')
      }), (0, _element.createElement)(_components.PanelBody, null, (0, _element.createElement)(_components.SelectControl, {
        icon: _icons.link,
        label: (0, _i18n.__)('Link to'),
        value: textLinkHref,
        onChange: this.onChangeLinkDestinationOption,
        options: linkDestinationOptions
      }), (0, _element.createElement)(_components.ToggleControl, {
        icon: _icons.external,
        label: (0, _i18n.__)('Open in new tab'),
        checked: textLinkTarget === '_blank',
        onChange: this.onChangeOpenInNewWindow
      }), !isSidebarLinkSettings && (0, _element.createElement)(_components.ToggleControl, {
        icon: _icons.button,
        label: (0, _i18n.__)('Show download button'),
        checked: showDownloadButton,
        onChange: this.onChangeDownloadButtonVisibility
      }), (0, _element.createElement)(_components.TextControl, {
        disabled: isCopyUrlDisabled,
        label: this.state.isUrlCopied ? (0, _i18n.__)('Copied!') : (0, _i18n.__)('Copy file URL'),
        labelStyle: this.state.isUrlCopied || finalButtonStyle,
        onPress: this.onCopyURL
      })));
    }
  }, {
    key: "getStyleForAlignment",
    value: function getStyleForAlignment(align) {
      var getFlexAlign = function getFlexAlign(alignment) {
        switch (alignment) {
          case 'right':
            return 'flex-end';

          case 'center':
            return 'center';

          default:
            return 'flex-start';
        }
      };

      return {
        alignSelf: getFlexAlign(align)
      };
    }
  }, {
    key: "getTextAlignmentForAlignment",
    value: function getTextAlignmentForAlignment(align) {
      switch (align) {
        case 'right':
          return 'right';

        case 'center':
          return 'center';

        default:
          return 'left';
      }
    }
  }, {
    key: "onFilePressed",
    value: function onFilePressed() {
      var attributes = this.props.attributes;

      if (this.state.isUploadInProgress) {
        (0, _reactNativeBridge.requestImageUploadCancelDialog)(attributes.id);
      } else if (attributes.id && (0, _url.getProtocol)(attributes.href) === 'file:') {
        (0, _reactNativeBridge.requestImageFailedRetryDialog)(attributes.id);
      }
    }
  }, {
    key: "onLayout",
    value: function onLayout(_ref2) {
      var nativeEvent = _ref2.nativeEvent;
      var width = nativeEvent.layout.width;
      var _styles$defaultButton = _style.default.defaultButton,
          paddingLeft = _styles$defaultButton.paddingLeft,
          paddingRight = _styles$defaultButton.paddingRight;
      this.setState({
        maxWidth: width - (paddingLeft + paddingRight)
      });
    } // Render `Text` with `placeholderText` styled as a placeholder
    // to calculate its width which then is set as a `minWidth`
    // This should be fixed on RNAztec level. In the mean time,
    // We use the same strategy implemented in Button block

  }, {
    key: "getPlaceholderWidth",
    value: function getPlaceholderWidth(placeholderText) {
      var _this3 = this;

      var _this$state = this.state,
          maxWidth = _this$state.maxWidth,
          placeholderTextWidth = _this$state.placeholderTextWidth;
      return (0, _element.createElement)(_reactNative.Text, {
        style: _style.default.placeholder,
        onTextLayout: function onTextLayout(_ref3) {
          var nativeEvent = _ref3.nativeEvent;
          var textWidth = nativeEvent.lines[0] && nativeEvent.lines[0].width;

          if (textWidth && textWidth !== placeholderTextWidth) {
            _this3.setState({
              placeholderTextWidth: Math.min(textWidth, maxWidth)
            });
          }
        }
      }, placeholderText);
    }
  }, {
    key: "getFileComponent",
    value: function getFileComponent(openMediaOptions, getMediaOptions) {
      var _this4 = this;

      var _this$props2 = this.props,
          attributes = _this$props2.attributes,
          media = _this$props2.media,
          isSelected = _this$props2.isSelected;
      var _this$state2 = this.state,
          isButtonFocused = _this$state2.isButtonFocused,
          placeholderTextWidth = _this$state2.placeholderTextWidth;
      var fileName = attributes.fileName,
          downloadButtonText = attributes.downloadButtonText,
          id = attributes.id,
          showDownloadButton = attributes.showDownloadButton,
          align = attributes.align;
      var minWidth = isButtonFocused || !isButtonFocused && downloadButtonText && downloadButtonText !== '' ? MIN_WIDTH : placeholderTextWidth;
      var placeholderText = isButtonFocused || !isButtonFocused && downloadButtonText && downloadButtonText !== '' ? '' : (0, _i18n.__)('Add text…');
      return (0, _element.createElement)(_blockEditor.MediaUploadProgress, {
        mediaId: id,
        onUpdateMediaProgress: this.updateMediaProgress,
        onFinishMediaUploadWithSuccess: this.finishMediaUploadWithSuccess,
        onFinishMediaUploadWithFailure: this.finishMediaUploadWithFailure,
        onMediaUploadStateReset: this.mediaUploadStateReset,
        renderContent: function renderContent(_ref4) {
          var isUploadInProgress = _ref4.isUploadInProgress,
              isUploadFailed = _ref4.isUploadFailed;
          var dimmedStyle = (_this4.state.isUploadInProgress || isUploadFailed) && _style.default.disabledButton;
          var finalButtonStyle = [_style.default.defaultButton, dimmedStyle];
          var errorIconStyle = Object.assign({}, _style.default.errorIcon, _style.default.uploadFailed);
          return (0, _element.createElement)(_reactNative.TouchableWithoutFeedback, {
            accessible: !isSelected,
            onPress: _this4.onFilePressed,
            onLongPress: openMediaOptions,
            disabled: !isSelected
          }, (0, _element.createElement)(_reactNative.View, {
            onLayout: _this4.onLayout
          }, _this4.getPlaceholderWidth(placeholderText), isUploadInProgress || _this4.getToolbarEditButton(openMediaOptions), getMediaOptions(), isSelected && _this4.getInspectorControls(attributes, media, isUploadInProgress, isUploadFailed), (0, _element.createElement)(_reactNative.View, {
            style: _style.default.container
          }, (0, _element.createElement)(_blockEditor.RichText, {
            withoutInteractiveFormatting: true,
            __unstableMobileNoFocusOnMount: true,
            onChange: _this4.onChangeFileName,
            placeholder: (0, _i18n.__)('File name'),
            rootTagsToEliminate: ['p'],
            tagName: "p",
            underlineColorAndroid: "transparent",
            value: fileName,
            deleteEnter: true,
            textAlign: _this4.getTextAlignmentForAlignment(align)
          }), isUploadFailed && (0, _element.createElement)(_reactNative.View, {
            style: _style.default.errorContainer
          }, (0, _element.createElement)(_components.Icon, {
            icon: _icons.warning,
            style: errorIconStyle
          }), (0, _element.createElement)(_blockEditor.PlainText, {
            editable: false,
            value: (0, _i18n.__)('Error'),
            style: _style.default.uploadFailed
          }))), showDownloadButton && _this4.state.maxWidth > 0 && (0, _element.createElement)(_reactNative.View, {
            style: [finalButtonStyle, _this4.getStyleForAlignment(align)]
          }, (0, _element.createElement)(_blockEditor.RichText, {
            withoutInteractiveFormatting: true,
            __unstableMobileNoFocusOnMount: true,
            rootTagsToEliminate: ['p'],
            tagName: "p",
            textAlign: "center",
            minWidth: minWidth,
            maxWidth: _this4.state.maxWidth,
            deleteEnter: true,
            style: _style.default.buttonText,
            value: downloadButtonText,
            placeholder: placeholderText,
            unstableOnFocus: function unstableOnFocus() {
              return _this4.setState({
                isButtonFocused: true
              });
            },
            onBlur: function onBlur() {
              return _this4.setState({
                isButtonFocused: false
              });
            },
            selectionColor: _style.default.buttonText.color,
            placeholderTextColor: _style.default.placeholderTextColor.color,
            underlineColorAndroid: "transparent",
            onChange: _this4.onChangeDownloadButtonText
          }))));
        }
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this5 = this;

      var attributes = this.props.attributes;
      var href = attributes.href;

      if (!href) {
        return (0, _element.createElement)(_blockEditor.MediaPlaceholder, {
          icon: (0, _element.createElement)(_blockEditor.BlockIcon, {
            icon: _icons.file
          }),
          labels: {
            title: (0, _i18n.__)('File'),
            instructions: (0, _i18n.__)('CHOOSE A FILE')
          },
          onSelect: this.onSelectFile,
          onFocus: this.props.onFocus,
          allowedTypes: [_blockEditor.MEDIA_TYPE_ANY]
        });
      }

      return (0, _element.createElement)(_blockEditor.MediaUpload, {
        allowedTypes: [_blockEditor.MEDIA_TYPE_ANY],
        isReplacingMedia: true,
        onSelect: this.onSelectFile,
        render: function render(_ref5) {
          var open = _ref5.open,
              getMediaOptions = _ref5.getMediaOptions;
          return _this5.getFileComponent(open, getMediaOptions);
        }
      });
    }
  }]);
  return FileEdit;
}(_element.Component);

exports.FileEdit = FileEdit;

var _default = (0, _compose.compose)([(0, _data.withSelect)(function (select, props) {
  var attributes = props.attributes;
  var id = attributes.id,
      href = attributes.href;

  var _select = select('core/edit-post'),
      isEditorSidebarOpened = _select.isEditorSidebarOpened;

  var isNotFileHref = id && (0, _url.getProtocol)(href) !== 'file:';
  return {
    media: isNotFileHref ? select('core').getMedia(id) : undefined,
    isSidebarOpened: isEditorSidebarOpened()
  };
}), (0, _data.withDispatch)(function (dispatch) {
  var _dispatch = dispatch('core/edit-post'),
      openGeneralSidebar = _dispatch.openGeneralSidebar;

  return {
    openSidebar: function openSidebar() {
      return openGeneralSidebar('edit-post/block');
    }
  };
}), _compose.withPreferredColorScheme])(FileEdit);

exports.default = _default;
//# sourceMappingURL=edit.native.js.map