{"version":3,"sources":["@wordpress/core-data/src/locks/selectors.js"],"names":["iterateDescendants","iteratePath","hasConflictingLock","getNode","__unstableGetPendingLockRequests","state","locks","requests","__unstableIsLockAvailable","store","path","exclusive","storePath","tree","node","descendant"],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA,SACCA,kBADD,EAECC,WAFD,EAGCC,kBAHD,EAICC,OAJD,QAKO,SALP;AAOA,OAAO,SAASC,gCAAT,CAA2CC,KAA3C,EAAmD;AACzD,SAAOA,KAAK,CAACC,KAAN,CAAYC,QAAnB;AACA;AAED,OAAO,SAASC,yBAAT,CAAoCH,KAApC,EAA2CI,KAA3C,EAAkDC,IAAlD,QAAwE;AAAA,MAAdC,SAAc,QAAdA,SAAc;AAC9E,MAAMC,SAAS,IAAKH,KAAL,4BAAeC,IAAf,EAAf;AACA,MAAMJ,KAAK,GAAGD,KAAK,CAACC,KAAN,CAAYO,IAA1B,CAF8E,CAI9E;;AAJ8E,6CAK1DZ,WAAW,CAAEK,KAAF,EAASM,SAAT,CAL+C;AAAA;;AAAA;AAK9E,wDAAsD;AAAA,UAA1CE,KAA0C;;AACrD,UAAKZ,kBAAkB,CAAE;AAAES,QAAAA,SAAS,EAATA;AAAF,OAAF,EAAiBG,KAAI,CAACR,KAAtB,CAAvB,EAAuD;AACtD,eAAO,KAAP;AACA;AACD,KAT6E,CAW9E;AACA;;AAZ8E;AAAA;AAAA;AAAA;AAAA;;AAa9E,MAAMQ,IAAI,GAAGX,OAAO,CAAEG,KAAF,EAASM,SAAT,CAApB;;AACA,MAAK,CAAEE,IAAP,EAAc;AACb,WAAO,IAAP;AACA,GAhB6E,CAkB9E;;;AAlB8E,8CAmBpDd,kBAAkB,CAAEc,IAAF,CAnBkC;AAAA;;AAAA;AAmB9E,2DAAuD;AAAA,UAA3CC,UAA2C;;AACtD,UAAKb,kBAAkB,CAAE;AAAES,QAAAA,SAAS,EAATA;AAAF,OAAF,EAAiBI,UAAU,CAACT,KAA5B,CAAvB,EAA6D;AAC5D,eAAO,KAAP;AACA;AACD;AAvB6E;AAAA;AAAA;AAAA;AAAA;;AAyB9E,SAAO,IAAP;AACA","sourcesContent":["/**\n * Internal dependencies\n */\nimport {\n\titerateDescendants,\n\titeratePath,\n\thasConflictingLock,\n\tgetNode,\n} from './utils';\n\nexport function __unstableGetPendingLockRequests( state ) {\n\treturn state.locks.requests;\n}\n\nexport function __unstableIsLockAvailable( state, store, path, { exclusive } ) {\n\tconst storePath = [ store, ...path ];\n\tconst locks = state.locks.tree;\n\n\t// Validate all parents and the node itself\n\tfor ( const node of iteratePath( locks, storePath ) ) {\n\t\tif ( hasConflictingLock( { exclusive }, node.locks ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// iteratePath terminates early if path is unreachable, let's\n\t// re-fetch the node and check it exists in the tree.\n\tconst node = getNode( locks, storePath );\n\tif ( ! node ) {\n\t\treturn true;\n\t}\n\n\t// Validate all nested nodes\n\tfor ( const descendant of iterateDescendants( node ) ) {\n\t\tif ( hasConflictingLock( { exclusive }, descendant.locks ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n"]}