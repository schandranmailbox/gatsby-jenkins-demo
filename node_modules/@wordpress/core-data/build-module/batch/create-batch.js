import _construct from "@babel/runtime/helpers/esm/construct";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * External dependencies
 */
import { isFunction, zip } from 'lodash';
/**
 * Internal dependencies
 */

import defaultProcessor from './default-processor';
/**
 * Creates a batch, which can be used to combine multiple API requests into one
 * API request using the WordPress batch processing API (/v1/batch).
 *
 * ```
 * const batch = createBatch();
 * const dunePromise = batch.add( {
 *   path: '/v1/books',
 *   method: 'POST',
 *   data: { title: 'Dune' }
 * } );
 * const lotrPromise = batch.add( {
 *   path: '/v1/books',
 *   method: 'POST',
 *   data: { title: 'Lord of the Rings' }
 * } );
 * const isSuccess = await batch.run(); // Sends one POST to /v1/batch.
 * if ( isSuccess ) {
 *   console.log(
 *     'Saved two books:',
 *     await dunePromise,
 *     await lotrPromise
 *   );
 * }
 * ```
 *
 * @param {Function} [processor] Processor function. Can be used to replace the
 *                               default functionality which is to send an API
 *                               request to /v1/batch. Is given an array of
 *                               inputs and must return a promise that
 *                               resolves to an array of objects containing
 *                               either `output` or `error`.
 */

export default function createBatch() {
  var processor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultProcessor;
  var lastId = 0;
  var queue = [];
  var pending = new ObservableSet();
  return {
    /**
     * Adds an input to the batch and returns a promise that is resolved or
     * rejected when the input is processed by `batch.run()`.
     *
     * You may also pass a thunk which allows inputs to be added
     * asychronously.
     *
     * ```
     * // Both are allowed:
     * batch.add( { path: '/v1/books', ... } );
     * batch.add( ( add ) => add( { path: '/v1/books', ... } ) );
     * ```
     *
     * If a thunk is passed, `batch.run()` will pause until either:
     *
     * - The thunk calls its `add` argument, or;
     * - The thunk returns a promise and that promise resolves, or;
     * - The thunk returns a non-promise.
     *
     * @param {any|Function} inputOrThunk Input to add or thunk to execute.
     
     * @return {Promise|any} If given an input, returns a promise that
     *                       is resolved or rejected when the batch is
     *                       processed. If given a thunk, returns the return
     *                       value of that thunk.
     */
    add: function add(inputOrThunk) {
      var id = ++lastId;
      pending.add(id);

      var add = function add(input) {
        return new Promise(function (resolve, reject) {
          queue.push({
            input: input,
            resolve: resolve,
            reject: reject
          });
          pending.delete(id);
        });
      };

      if (isFunction(inputOrThunk)) {
        return Promise.resolve(inputOrThunk(add)).finally(function () {
          pending.delete(id);
        });
      }

      return add(inputOrThunk);
    },

    /**
     * Runs the batch. This calls `batchProcessor` and resolves or rejects
     * all promises returned by `add()`.
     *
     * @return {Promise} A promise that resolves to a boolean that is true
     *                   if the processor returned no errors.
     */
    run: function run() {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var results, _iterator, _step, reject, isSuccess, _iterator2, _step2, _step2$value, result, _step2$value$, resolve, _reject, _result$output;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!pending.size) {
                  _context.next = 3;
                  break;
                }

                _context.next = 3;
                return new Promise(function (resolve) {
                  var unsubscribe = pending.subscribe(function () {
                    if (!pending.size) {
                      unsubscribe();
                      resolve();
                    }
                  });
                });

              case 3:
                _context.prev = 3;
                _context.next = 6;
                return processor(queue.map(function (_ref) {
                  var input = _ref.input;
                  return input;
                }));

              case 6:
                results = _context.sent;

                if (!(results.length !== queue.length)) {
                  _context.next = 9;
                  break;
                }

                throw new Error('run: Array returned by processor must be same size as input array.');

              case 9:
                _context.next = 16;
                break;

              case 11:
                _context.prev = 11;
                _context.t0 = _context["catch"](3);
                _iterator = _createForOfIteratorHelper(queue);

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    reject = _step.value.reject;
                    reject(_context.t0);
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                throw _context.t0;

              case 16:
                isSuccess = true;
                _iterator2 = _createForOfIteratorHelper(zip(results, queue));

                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    _step2$value = _slicedToArray(_step2.value, 2), result = _step2$value[0], _step2$value$ = _step2$value[1], resolve = _step2$value$.resolve, _reject = _step2$value$.reject;

                    if (result !== null && result !== void 0 && result.error) {
                      _reject(result.error);

                      isSuccess = false;
                    } else {
                      resolve((_result$output = result === null || result === void 0 ? void 0 : result.output) !== null && _result$output !== void 0 ? _result$output : result);
                    }
                  }
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }

                queue = [];
                return _context.abrupt("return", isSuccess);

              case 21:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[3, 11]]);
      }))();
    }
  };
}

var ObservableSet = /*#__PURE__*/function () {
  function ObservableSet() {
    _classCallCheck(this, ObservableSet);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.set = _construct(Set, args);
    this.subscribers = new Set();
  }

  _createClass(ObservableSet, [{
    key: "add",
    value: function add() {
      var _this$set;

      (_this$set = this.set).add.apply(_this$set, arguments);

      this.subscribers.forEach(function (subscriber) {
        return subscriber();
      });
      return this;
    }
  }, {
    key: "delete",
    value: function _delete() {
      var _this$set2;

      var isSuccess = (_this$set2 = this.set).delete.apply(_this$set2, arguments);

      this.subscribers.forEach(function (subscriber) {
        return subscriber();
      });
      return isSuccess;
    }
  }, {
    key: "subscribe",
    value: function subscribe(subscriber) {
      var _this = this;

      this.subscribers.add(subscriber);
      return function () {
        _this.subscribers.delete(subscriber);
      };
    }
  }, {
    key: "size",
    get: function get() {
      return this.set.size;
    }
  }]);

  return ObservableSet;
}();
//# sourceMappingURL=create-batch.js.map