import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _toArray from "@babel/runtime/helpers/esm/toArray";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

var _marked = /*#__PURE__*/_regeneratorRuntime.mark(deleteEntityRecord),
    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(editEntityRecord),
    _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(undo),
    _marked4 = /*#__PURE__*/_regeneratorRuntime.mark(redo),
    _marked5 = /*#__PURE__*/_regeneratorRuntime.mark(saveEntityRecord),
    _marked6 = /*#__PURE__*/_regeneratorRuntime.mark(__experimentalBatch),
    _marked7 = /*#__PURE__*/_regeneratorRuntime.mark(saveEditedEntityRecord);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * External dependencies
 */
import { castArray, get, isEqual, find } from 'lodash';
import { v4 as uuid } from 'uuid';
/**
 * WordPress dependencies
 */

import { controls } from '@wordpress/data';
import { apiFetch, __unstableAwaitPromise } from '@wordpress/data-controls';
import { addQueryArgs } from '@wordpress/url';
/**
 * Internal dependencies
 */

import { receiveItems, removeItems, receiveQueriedItems } from './queried-data';
import { getKindEntities, DEFAULT_ENTITY_KEY } from './entities';
import { __unstableAcquireStoreLock, __unstableReleaseStoreLock } from './locks';
import { createBatch } from './batch';
import { getDispatch } from './controls';
/**
 * Returns an action object used in signalling that authors have been received.
 *
 * @param {string}       queryID Query ID.
 * @param {Array|Object} users   Users received.
 *
 * @return {Object} Action object.
 */

export function receiveUserQuery(queryID, users) {
  return {
    type: 'RECEIVE_USER_QUERY',
    users: castArray(users),
    queryID: queryID
  };
}
/**
 * Returns an action used in signalling that the current user has been received.
 *
 * @param {Object} currentUser Current user object.
 *
 * @return {Object} Action object.
 */

export function receiveCurrentUser(currentUser) {
  return {
    type: 'RECEIVE_CURRENT_USER',
    currentUser: currentUser
  };
}
/**
 * Returns an action object used in adding new entities.
 *
 * @param {Array} entities  Entities received.
 *
 * @return {Object} Action object.
 */

export function addEntities(entities) {
  return {
    type: 'ADD_ENTITIES',
    entities: entities
  };
}
/**
 * Returns an action object used in signalling that entity records have been received.
 *
 * @param {string}       kind            Kind of the received entity.
 * @param {string}       name            Name of the received entity.
 * @param {Array|Object} records         Records received.
 * @param {?Object}      query           Query Object.
 * @param {?boolean}     invalidateCache Should invalidate query caches.
 * @param {?Object}      edits           Edits to reset.
 * @return {Object} Action object.
 */

export function receiveEntityRecords(kind, name, records, query) {
  var invalidateCache = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var edits = arguments.length > 5 ? arguments[5] : undefined;

  // Auto drafts should not have titles, but some plugins rely on them so we can't filter this
  // on the server.
  if (kind === 'postType') {
    records = castArray(records).map(function (record) {
      return record.status === 'auto-draft' ? _objectSpread(_objectSpread({}, record), {}, {
        title: ''
      }) : record;
    });
  }

  var action;

  if (query) {
    action = receiveQueriedItems(records, query, edits);
  } else {
    action = receiveItems(records, edits);
  }

  return _objectSpread(_objectSpread({}, action), {}, {
    kind: kind,
    name: name,
    invalidateCache: invalidateCache
  });
}
/**
 * Returns an action object used in signalling that the current theme has been received.
 *
 * @param {Object} currentTheme The current theme.
 *
 * @return {Object} Action object.
 */

export function receiveCurrentTheme(currentTheme) {
  return {
    type: 'RECEIVE_CURRENT_THEME',
    currentTheme: currentTheme
  };
}
/**
 * Returns an action object used in signalling that the index has been received.
 *
 * @param {Object} themeSupports Theme support for the current theme.
 *
 * @return {Object} Action object.
 */

export function receiveThemeSupports(themeSupports) {
  return {
    type: 'RECEIVE_THEME_SUPPORTS',
    themeSupports: themeSupports
  };
}
/**
 * Returns an action object used in signalling that the preview data for
 * a given URl has been received.
 *
 * @param {string}  url     URL to preview the embed for.
 * @param {*}       preview Preview data.
 *
 * @return {Object} Action object.
 */

export function receiveEmbedPreview(url, preview) {
  return {
    type: 'RECEIVE_EMBED_PREVIEW',
    url: url,
    preview: preview
  };
}
/**
 * Action triggered to delete an entity record.
 *
 * @param {string}   kind                      Kind of the deleted entity.
 * @param {string}   name                      Name of the deleted entity.
 * @param {string}   recordId                  Record ID of the deleted entity.
 * @param {?Object}  query                     Special query parameters for the
 *                                             DELETE API call.
 * @param {Object}   [options]                 Delete options.
 * @param {Function} [options.__unstableFetch] Internal use only. Function to
 *                                             call instead of `apiFetch()`.
 *                                             Must return a control descriptor.
 */

export function deleteEntityRecord(kind, name, recordId, query) {
  var _ref,
      _ref$__unstableFetch,
      __unstableFetch,
      entities,
      entity,
      error,
      deletedRecord,
      lock,
      path,
      options,
      _args = arguments;

  return _regeneratorRuntime.wrap(function deleteEntityRecord$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _ref = _args.length > 4 && _args[4] !== undefined ? _args[4] : {}, _ref$__unstableFetch = _ref.__unstableFetch, __unstableFetch = _ref$__unstableFetch === void 0 ? null : _ref$__unstableFetch;
          _context.next = 3;
          return getKindEntities(kind);

        case 3:
          entities = _context.sent;
          entity = find(entities, {
            kind: kind,
            name: name
          });
          deletedRecord = false;

          if (entity) {
            _context.next = 8;
            break;
          }

          return _context.abrupt("return");

        case 8:
          return _context.delegateYield(__unstableAcquireStoreLock('core', ['entities', 'data', kind, name, recordId], {
            exclusive: true
          }), "t0", 9);

        case 9:
          lock = _context.t0;
          _context.prev = 10;
          _context.next = 13;
          return {
            type: 'DELETE_ENTITY_RECORD_START',
            kind: kind,
            name: name,
            recordId: recordId
          };

        case 13:
          _context.prev = 13;
          path = "".concat(entity.baseURL, "/").concat(recordId);

          if (query) {
            path = addQueryArgs(path, query);
          }

          options = {
            path: path,
            method: 'DELETE'
          };

          if (!__unstableFetch) {
            _context.next = 23;
            break;
          }

          _context.next = 20;
          return __unstableAwaitPromise(__unstableFetch(options));

        case 20:
          deletedRecord = _context.sent;
          _context.next = 26;
          break;

        case 23:
          _context.next = 25;
          return apiFetch(options);

        case 25:
          deletedRecord = _context.sent;

        case 26:
          _context.next = 28;
          return removeItems(kind, name, recordId, true);

        case 28:
          _context.next = 33;
          break;

        case 30:
          _context.prev = 30;
          _context.t1 = _context["catch"](13);
          error = _context.t1;

        case 33:
          _context.next = 35;
          return {
            type: 'DELETE_ENTITY_RECORD_FINISH',
            kind: kind,
            name: name,
            recordId: recordId,
            error: error
          };

        case 35:
          return _context.abrupt("return", deletedRecord);

        case 36:
          _context.prev = 36;
          return _context.delegateYield(__unstableReleaseStoreLock(lock), "t2", 38);

        case 38:
          return _context.finish(36);

        case 39:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[10,, 36, 39], [13, 30]]);
}
/**
 * Returns an action object that triggers an
 * edit to an entity record.
 *
 * @param {string} kind     Kind of the edited entity record.
 * @param {string} name     Name of the edited entity record.
 * @param {number} recordId Record ID of the edited entity record.
 * @param {Object} edits    The edits.
 * @param {Object} options  Options for the edit.
 * @param {boolean} options.undoIgnore Whether to ignore the edit in undo history or not.
 *
 * @return {Object} Action object.
 */

export function editEntityRecord(kind, name, recordId, edits) {
  var options,
      entity,
      _entity$transientEdit,
      transientEdits,
      _entity$mergedEdits,
      mergedEdits,
      record,
      editedRecord,
      edit,
      _args2 = arguments;

  return _regeneratorRuntime.wrap(function editEntityRecord$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          options = _args2.length > 4 && _args2[4] !== undefined ? _args2[4] : {};
          _context2.next = 3;
          return controls.select('core', 'getEntity', kind, name);

        case 3:
          entity = _context2.sent;

          if (entity) {
            _context2.next = 6;
            break;
          }

          throw new Error("The entity being edited (".concat(kind, ", ").concat(name, ") does not have a loaded config."));

        case 6:
          _entity$transientEdit = entity.transientEdits, transientEdits = _entity$transientEdit === void 0 ? {} : _entity$transientEdit, _entity$mergedEdits = entity.mergedEdits, mergedEdits = _entity$mergedEdits === void 0 ? {} : _entity$mergedEdits;
          _context2.next = 9;
          return controls.select('core', 'getRawEntityRecord', kind, name, recordId);

        case 9:
          record = _context2.sent;
          _context2.next = 12;
          return controls.select('core', 'getEditedEntityRecord', kind, name, recordId);

        case 12:
          editedRecord = _context2.sent;
          edit = {
            kind: kind,
            name: name,
            recordId: recordId,
            // Clear edits when they are equal to their persisted counterparts
            // so that the property is not considered dirty.
            edits: Object.keys(edits).reduce(function (acc, key) {
              var recordValue = record[key];
              var editedRecordValue = editedRecord[key];
              var value = mergedEdits[key] ? _objectSpread(_objectSpread({}, editedRecordValue), edits[key]) : edits[key];
              acc[key] = isEqual(recordValue, value) ? undefined : value;
              return acc;
            }, {}),
            transientEdits: transientEdits
          };
          return _context2.abrupt("return", _objectSpread(_objectSpread({
            type: 'EDIT_ENTITY_RECORD'
          }, edit), {}, {
            meta: {
              undo: !options.undoIgnore && _objectSpread(_objectSpread({}, edit), {}, {
                // Send the current values for things like the first undo stack entry.
                edits: Object.keys(edits).reduce(function (acc, key) {
                  acc[key] = editedRecord[key];
                  return acc;
                }, {})
              })
            }
          }));

        case 15:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2);
}
/**
 * Action triggered to undo the last edit to
 * an entity record, if any.
 */

export function undo() {
  var undoEdit;
  return _regeneratorRuntime.wrap(function undo$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return controls.select('core', 'getUndoEdit');

        case 2:
          undoEdit = _context3.sent;

          if (undoEdit) {
            _context3.next = 5;
            break;
          }

          return _context3.abrupt("return");

        case 5:
          _context3.next = 7;
          return _objectSpread(_objectSpread({
            type: 'EDIT_ENTITY_RECORD'
          }, undoEdit), {}, {
            meta: {
              isUndo: true
            }
          });

        case 7:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3);
}
/**
 * Action triggered to redo the last undoed
 * edit to an entity record, if any.
 */

export function redo() {
  var redoEdit;
  return _regeneratorRuntime.wrap(function redo$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return controls.select('core', 'getRedoEdit');

        case 2:
          redoEdit = _context4.sent;

          if (redoEdit) {
            _context4.next = 5;
            break;
          }

          return _context4.abrupt("return");

        case 5:
          _context4.next = 7;
          return _objectSpread(_objectSpread({
            type: 'EDIT_ENTITY_RECORD'
          }, redoEdit), {}, {
            meta: {
              isRedo: true
            }
          });

        case 7:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4);
}
/**
 * Forces the creation of a new undo level.
 *
 * @return {Object} Action object.
 */

export function __unstableCreateUndoLevel() {
  return {
    type: 'CREATE_UNDO_LEVEL'
  };
}
/**
 * Action triggered to save an entity record.
 *
 * @param {string}   kind                       Kind of the received entity.
 * @param {string}   name                       Name of the received entity.
 * @param {Object}   record                     Record to be saved.
 * @param {Object}   options                    Saving options.
 * @param {boolean}  [options.isAutosave=false] Whether this is an autosave.
 * @param {Function} [options.__unstableFetch]  Internal use only. Function to
 *                                              call instead of `apiFetch()`.
 *                                              Must return a control
 *                                              descriptor.
 */

export function saveEntityRecord(kind, name, record) {
  var _ref2,
      _ref2$isAutosave,
      isAutosave,
      _ref2$__unstableFetch,
      __unstableFetch,
      entities,
      entity,
      entityIdKey,
      recordId,
      lock,
      _i,
      _Object$entries,
      _Object$entries$_i,
      key,
      value,
      evaluatedValue,
      updatedRecord,
      error,
      path,
      persistedRecord,
      currentUser,
      currentUserId,
      autosavePost,
      data,
      options,
      newRecord,
      edits,
      _options,
      _args5 = arguments;

  return _regeneratorRuntime.wrap(function saveEntityRecord$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _ref2 = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : {}, _ref2$isAutosave = _ref2.isAutosave, isAutosave = _ref2$isAutosave === void 0 ? false : _ref2$isAutosave, _ref2$__unstableFetch = _ref2.__unstableFetch, __unstableFetch = _ref2$__unstableFetch === void 0 ? null : _ref2$__unstableFetch;
          _context5.next = 3;
          return getKindEntities(kind);

        case 3:
          entities = _context5.sent;
          entity = find(entities, {
            kind: kind,
            name: name
          });

          if (entity) {
            _context5.next = 7;
            break;
          }

          return _context5.abrupt("return");

        case 7:
          entityIdKey = entity.key || DEFAULT_ENTITY_KEY;
          recordId = record[entityIdKey];
          return _context5.delegateYield(__unstableAcquireStoreLock('core', ['entities', 'data', kind, name, recordId || uuid()], {
            exclusive: true
          }), "t0", 10);

        case 10:
          lock = _context5.t0;
          _context5.prev = 11;
          _i = 0, _Object$entries = Object.entries(record);

        case 13:
          if (!(_i < _Object$entries.length)) {
            _context5.next = 27;
            break;
          }

          _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];

          if (!(typeof value === 'function')) {
            _context5.next = 24;
            break;
          }

          _context5.t1 = value;
          _context5.next = 19;
          return controls.select('core', 'getEditedEntityRecord', kind, name, recordId);

        case 19:
          _context5.t2 = _context5.sent;
          evaluatedValue = (0, _context5.t1)(_context5.t2);
          _context5.next = 23;
          return editEntityRecord(kind, name, recordId, _defineProperty({}, key, evaluatedValue), {
            undoIgnore: true
          });

        case 23:
          record[key] = evaluatedValue;

        case 24:
          _i++;
          _context5.next = 13;
          break;

        case 27:
          _context5.next = 29;
          return {
            type: 'SAVE_ENTITY_RECORD_START',
            kind: kind,
            name: name,
            recordId: recordId,
            isAutosave: isAutosave
          };

        case 29:
          _context5.prev = 29;
          path = "".concat(entity.baseURL).concat(recordId ? '/' + recordId : '');
          _context5.next = 33;
          return controls.select('core', 'getRawEntityRecord', kind, name, recordId);

        case 33:
          persistedRecord = _context5.sent;

          if (!isAutosave) {
            _context5.next = 65;
            break;
          }

          _context5.next = 37;
          return controls.select('core', 'getCurrentUser');

        case 37:
          currentUser = _context5.sent;
          currentUserId = currentUser ? currentUser.id : undefined;
          _context5.next = 41;
          return controls.select('core', 'getAutosave', persistedRecord.type, persistedRecord.id, currentUserId);

        case 41:
          autosavePost = _context5.sent;
          // Autosaves need all expected fields to be present.
          // So we fallback to the previous autosave and then
          // to the actual persisted entity if the edits don't
          // have a value.
          data = _objectSpread(_objectSpread(_objectSpread({}, persistedRecord), autosavePost), record);
          data = Object.keys(data).reduce(function (acc, key) {
            if (['title', 'excerpt', 'content'].includes(key)) {
              // Edits should be the "raw" attribute values.
              acc[key] = get(data[key], 'raw', data[key]);
            }

            return acc;
          }, {
            status: data.status === 'auto-draft' ? 'draft' : data.status
          });
          options = {
            path: "".concat(path, "/autosaves"),
            method: 'POST',
            data: data
          };

          if (!__unstableFetch) {
            _context5.next = 51;
            break;
          }

          _context5.next = 48;
          return __unstableAwaitPromise(__unstableFetch(options));

        case 48:
          updatedRecord = _context5.sent;
          _context5.next = 54;
          break;

        case 51:
          _context5.next = 53;
          return apiFetch(options);

        case 53:
          updatedRecord = _context5.sent;

        case 54:
          if (!(persistedRecord.id === updatedRecord.id)) {
            _context5.next = 61;
            break;
          }

          newRecord = _objectSpread(_objectSpread(_objectSpread({}, persistedRecord), data), updatedRecord);
          newRecord = Object.keys(newRecord).reduce(function (acc, key) {
            // These properties are persisted in autosaves.
            if (['title', 'excerpt', 'content'].includes(key)) {
              // Edits should be the "raw" attribute values.
              acc[key] = get(newRecord[key], 'raw', newRecord[key]);
            } else if (key === 'status') {
              // Status is only persisted in autosaves when going from
              // "auto-draft" to "draft".
              acc[key] = persistedRecord.status === 'auto-draft' && newRecord.status === 'draft' ? newRecord.status : persistedRecord.status;
            } else {
              // These properties are not persisted in autosaves.
              acc[key] = get(persistedRecord[key], 'raw', persistedRecord[key]);
            }

            return acc;
          }, {});
          _context5.next = 59;
          return receiveEntityRecords(kind, name, newRecord, undefined, true);

        case 59:
          _context5.next = 63;
          break;

        case 61:
          _context5.next = 63;
          return receiveAutosaves(persistedRecord.id, updatedRecord);

        case 63:
          _context5.next = 79;
          break;

        case 65:
          edits = record;

          if (entity.__unstablePrePersist) {
            edits = _objectSpread(_objectSpread({}, edits), entity.__unstablePrePersist(persistedRecord, edits));
          }

          _options = {
            path: path,
            method: recordId ? 'PUT' : 'POST',
            data: edits
          };

          if (!__unstableFetch) {
            _context5.next = 74;
            break;
          }

          _context5.next = 71;
          return __unstableAwaitPromise(__unstableFetch(_options));

        case 71:
          updatedRecord = _context5.sent;
          _context5.next = 77;
          break;

        case 74:
          _context5.next = 76;
          return apiFetch(_options);

        case 76:
          updatedRecord = _context5.sent;

        case 77:
          _context5.next = 79;
          return receiveEntityRecords(kind, name, updatedRecord, undefined, true, edits);

        case 79:
          _context5.next = 84;
          break;

        case 81:
          _context5.prev = 81;
          _context5.t3 = _context5["catch"](29);
          error = _context5.t3;

        case 84:
          _context5.next = 86;
          return {
            type: 'SAVE_ENTITY_RECORD_FINISH',
            kind: kind,
            name: name,
            recordId: recordId,
            error: error,
            isAutosave: isAutosave
          };

        case 86:
          return _context5.abrupt("return", updatedRecord);

        case 87:
          _context5.prev = 87;
          return _context5.delegateYield(__unstableReleaseStoreLock(lock), "t4", 89);

        case 89:
          return _context5.finish(87);

        case 90:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5, null, [[11,, 87, 90], [29, 81]]);
}
/**
 * Runs multiple core-data actions at the same time using one API request.
 *
 * Example:
 *
 * ```
 * const [ savedRecord, updatedRecord, deletedRecord ] =
 *   await dispatch( 'core' ).__experimentalBatch( [
 *     ( { saveEntityRecord } ) => saveEntityRecord( 'root', 'widget', widget ),
 *     ( { saveEditedEntityRecord } ) => saveEntityRecord( 'root', 'widget', 123 ),
 *     ( { deleteEntityRecord } ) => deleteEntityRecord( 'root', 'widget', 123, null ),
 *   ] );
 * ```
 *
 * @param {Array} requests Array of functions which are invoked simultaneously.
 *                         Each function is passed an object containing
 *                         `saveEntityRecord`, `saveEditedEntityRecord`, and
 *                         `deleteEntityRecord`.
 *
 * @return {Promise} A promise that resolves to an array containing the return
 *                   values of each function given in `requests`.
 */

export function __experimentalBatch(requests) {
  var batch, dispatch, api, resultPromises, _yield$__unstableAwai, _yield$__unstableAwai2, results;

  return _regeneratorRuntime.wrap(function __experimentalBatch$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          batch = createBatch();
          _context6.next = 3;
          return getDispatch();

        case 3:
          dispatch = _context6.sent;
          api = {
            saveEntityRecord: function saveEntityRecord(kind, name, record, options) {
              return batch.add(function (add) {
                return dispatch('core').saveEntityRecord(kind, name, record, _objectSpread(_objectSpread({}, options), {}, {
                  __unstableFetch: add
                }));
              });
            },
            saveEditedEntityRecord: function saveEditedEntityRecord(kind, name, recordId, options) {
              return batch.add(function (add) {
                return dispatch('core').saveEditedEntityRecord(kind, name, recordId, _objectSpread(_objectSpread({}, options), {}, {
                  __unstableFetch: add
                }));
              });
            },
            deleteEntityRecord: function deleteEntityRecord(kind, name, recordId, query, options) {
              return batch.add(function (add) {
                return dispatch('core').deleteEntityRecord(kind, name, recordId, query, _objectSpread(_objectSpread({}, options), {}, {
                  __unstableFetch: add
                }));
              });
            }
          };
          resultPromises = requests.map(function (request) {
            return request(api);
          });
          _context6.next = 8;
          return __unstableAwaitPromise(Promise.all([batch.run()].concat(_toConsumableArray(resultPromises))));

        case 8:
          _yield$__unstableAwai = _context6.sent;
          _yield$__unstableAwai2 = _toArray(_yield$__unstableAwai);
          results = _yield$__unstableAwai2.slice(1);
          return _context6.abrupt("return", results);

        case 12:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked6);
}
/**
 * Action triggered to save an entity record's edits.
 *
 * @param {string} kind     Kind of the entity.
 * @param {string} name     Name of the entity.
 * @param {Object} recordId ID of the record.
 * @param {Object} options  Saving options.
 */

export function saveEditedEntityRecord(kind, name, recordId, options) {
  var edits, record;
  return _regeneratorRuntime.wrap(function saveEditedEntityRecord$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          _context7.next = 2;
          return controls.select('core', 'hasEditsForEntityRecord', kind, name, recordId);

        case 2:
          if (_context7.sent) {
            _context7.next = 4;
            break;
          }

          return _context7.abrupt("return");

        case 4:
          _context7.next = 6;
          return controls.select('core', 'getEntityRecordNonTransientEdits', kind, name, recordId);

        case 6:
          edits = _context7.sent;
          record = _objectSpread({
            id: recordId
          }, edits);
          return _context7.delegateYield(saveEntityRecord(kind, name, record, options), "t0", 9);

        case 9:
          return _context7.abrupt("return", _context7.t0);

        case 10:
        case "end":
          return _context7.stop();
      }
    }
  }, _marked7);
}
/**
 * Returns an action object used in signalling that Upload permissions have been received.
 *
 * @param {boolean} hasUploadPermissions Does the user have permission to upload files?
 *
 * @return {Object} Action object.
 */

export function receiveUploadPermissions(hasUploadPermissions) {
  return {
    type: 'RECEIVE_USER_PERMISSION',
    key: 'create/media',
    isAllowed: hasUploadPermissions
  };
}
/**
 * Returns an action object used in signalling that the current user has
 * permission to perform an action on a REST resource.
 *
 * @param {string}  key       A key that represents the action and REST resource.
 * @param {boolean} isAllowed Whether or not the user can perform the action.
 *
 * @return {Object} Action object.
 */

export function receiveUserPermission(key, isAllowed) {
  return {
    type: 'RECEIVE_USER_PERMISSION',
    key: key,
    isAllowed: isAllowed
  };
}
/**
 * Returns an action object used in signalling that the autosaves for a
 * post have been received.
 *
 * @param {number}       postId    The id of the post that is parent to the autosave.
 * @param {Array|Object} autosaves An array of autosaves or singular autosave object.
 *
 * @return {Object} Action object.
 */

export function receiveAutosaves(postId, autosaves) {
  return {
    type: 'RECEIVE_AUTOSAVES',
    postId: postId,
    autosaves: castArray(autosaves)
  };
}
//# sourceMappingURL=actions.js.map