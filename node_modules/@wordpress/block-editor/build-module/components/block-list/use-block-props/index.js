import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * External dependencies
 */
import classnames from 'classnames';
import { omit } from 'lodash';
/**
 * WordPress dependencies
 */

import { useRef, useEffect, useContext } from '@wordpress/element';
import { __, sprintf } from '@wordpress/i18n';
import { __unstableGetBlockProps as getBlockProps } from '@wordpress/blocks';
/**
 * Internal dependencies
 */

import useMovingAnimation from '../../use-moving-animation';
import { SetBlockNodes } from '../';
import { BlockListBlockContext } from '../block';
import { useFocusFirstElement } from './use-focus-first-element';
import { useIsHovered } from './use-is-hovered';
import { useBlockMovingModeClassNames } from './use-block-moving-mode-class-names';
import { useEventHandlers } from './use-event-handlers';
/**
 * This hook is used to lightly mark an element as a block element. The element
 * should be the outermost element of a block. Call this hook and pass the
 * returned props to the element to mark as a block. If you define a ref for the
 * element, it is important to pass the ref to this hook, which the hook in turn
 * will pass to the component through the props it returns. Optionally, you can
 * also pass any other props through this hook, and they will be merged and
 * returned.
 *
 * @param {Object}  props   Optional. Props to pass to the element. Must contain
 *                          the ref if one is defined.
 * @param {Object}  options Options for internal use only.
 * @param {boolean} options.__unstableIsHtml
 *
 * @return {Object} Props to pass to the element to mark as a block.
 */

export function useBlockProps() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      __unstableIsHtml = _ref.__unstableIsHtml;

  var fallbackRef = useRef();
  var ref = props.ref || fallbackRef;
  var setBlockNodes = useContext(SetBlockNodes);

  var _useContext = useContext(BlockListBlockContext),
      clientId = _useContext.clientId,
      isSelected = _useContext.isSelected,
      isFirstMultiSelected = _useContext.isFirstMultiSelected,
      isLastMultiSelected = _useContext.isLastMultiSelected,
      isPartOfMultiSelection = _useContext.isPartOfMultiSelection,
      enableAnimation = _useContext.enableAnimation,
      index = _useContext.index,
      className = _useContext.className,
      name = _useContext.name,
      mode = _useContext.mode,
      blockTitle = _useContext.blockTitle,
      _useContext$wrapperPr = _useContext.wrapperProps,
      wrapperProps = _useContext$wrapperPr === void 0 ? {} : _useContext$wrapperPr; // Provide the selected node, or the first and last nodes of a multi-
  // selection, so it can be used to position the contextual block toolbar.
  // We only provide what is necessary, and remove the nodes again when they
  // are no longer selected.


  useEffect(function () {
    if (isSelected || isFirstMultiSelected || isLastMultiSelected) {
      var node = ref.current;
      setBlockNodes(function (nodes) {
        return _objectSpread(_objectSpread({}, nodes), {}, _defineProperty({}, clientId, node));
      });
      return function () {
        setBlockNodes(function (nodes) {
          return omit(nodes, clientId);
        });
      };
    }
  }, [isSelected, isFirstMultiSelected, isLastMultiSelected]); // Set new block node if it changes.
  // This effect should happen on every render, so no dependencies should be
  // added.

  useEffect(function () {
    var node = ref.current;
    setBlockNodes(function (nodes) {
      if (!nodes[clientId] || nodes[clientId] === node) {
        return nodes;
      }

      return _objectSpread(_objectSpread({}, nodes), {}, _defineProperty({}, clientId, node));
    });
  }); // translators: %s: Type of block (i.e. Text, Image etc)

  var blockLabel = sprintf(__('Block: %s'), blockTitle);
  useFocusFirstElement(ref, clientId);
  useEventHandlers(ref, clientId); // Block Reordering animation

  useMovingAnimation(ref, isSelected || isPartOfMultiSelection, isSelected || isFirstMultiSelected, enableAnimation, index);
  var isHovered = useIsHovered(ref);
  var blockMovingModeClassNames = useBlockMovingModeClassNames(clientId);
  var htmlSuffix = mode === 'html' && !__unstableIsHtml ? '-visual' : '';
  return _objectSpread(_objectSpread(_objectSpread({}, wrapperProps), props), {}, {
    ref: ref,
    id: "block-".concat(clientId).concat(htmlSuffix),
    tabIndex: 0,
    role: 'group',
    'aria-label': blockLabel,
    'data-block': clientId,
    'data-type': name,
    'data-title': blockTitle,
    className: classnames(className, props.className, wrapperProps.className, blockMovingModeClassNames, {
      'is-hovered': isHovered
    }),
    style: _objectSpread(_objectSpread({}, wrapperProps.style), props.style)
  });
}
/**
 * Call within a save function to get the props for the block wrapper.
 *
 * @param {Object} props Optional. Props to pass to the element.
 */

useBlockProps.save = getBlockProps;
//# sourceMappingURL=index.js.map