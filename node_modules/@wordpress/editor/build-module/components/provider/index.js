import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement } from "@wordpress/element";

/**
 * WordPress dependencies
 */
import { useEffect, useLayoutEffect, useMemo } from '@wordpress/element';
import { useDispatch, useSelect } from '@wordpress/data';
import { __ } from '@wordpress/i18n';
import { EntityProvider, useEntityBlockEditor } from '@wordpress/core-data';
import { BlockEditorProvider, BlockContextProvider } from '@wordpress/block-editor';
import { ReusableBlocksMenuItems } from '@wordpress/reusable-blocks';
import { store as noticesStore } from '@wordpress/notices';
/**
 * Internal dependencies
 */

import withRegistryProvider from './with-registry-provider';
import { store as editorStore } from '../../store';
import useBlockEditorSettings from './use-block-editor-settings';

function EditorProvider(_ref) {
  var __unstableTemplate = _ref.__unstableTemplate,
      post = _ref.post,
      settings = _ref.settings,
      recovery = _ref.recovery,
      initialEdits = _ref.initialEdits,
      children = _ref.children;
  var defaultBlockContext = useMemo(function () {
    if (post.type === 'wp_template') {
      return {};
    }

    return {
      postId: post.id,
      postType: post.type
    };
  }, [post.id, post.type]);

  var _useSelect = useSelect(function (select) {
    var _select = select(editorStore),
        getEditorSelectionStart = _select.getEditorSelectionStart,
        getEditorSelectionEnd = _select.getEditorSelectionEnd,
        __unstableIsEditorReady = _select.__unstableIsEditorReady;

    return {
      isReady: __unstableIsEditorReady(),
      selectionStart: getEditorSelectionStart(),
      selectionEnd: getEditorSelectionEnd()
    };
  }, []),
      selectionEnd = _useSelect.selectionEnd,
      selectionStart = _useSelect.selectionStart,
      isReady = _useSelect.isReady;

  var _ref2 = __unstableTemplate !== null && __unstableTemplate !== void 0 ? __unstableTemplate : post,
      id = _ref2.id,
      type = _ref2.type;

  var _useEntityBlockEditor = useEntityBlockEditor('postType', type, {
    id: id
  }),
      _useEntityBlockEditor2 = _slicedToArray(_useEntityBlockEditor, 3),
      blocks = _useEntityBlockEditor2[0],
      onInput = _useEntityBlockEditor2[1],
      onChange = _useEntityBlockEditor2[2];

  var editorSettings = useBlockEditorSettings(settings, !!__unstableTemplate);

  var _useDispatch = useDispatch(editorStore),
      updatePostLock = _useDispatch.updatePostLock,
      setupEditor = _useDispatch.setupEditor,
      updateEditorSettings = _useDispatch.updateEditorSettings,
      __experimentalTearDownEditor = _useDispatch.__experimentalTearDownEditor;

  var _useDispatch2 = useDispatch(noticesStore),
      createWarningNotice = _useDispatch2.createWarningNotice; // Iniitialize and tear down the editor.
  // Ideally this should be synced on each change and not just something you do once.


  useLayoutEffect(function () {
    // Assume that we don't need to initialize in the case of an error recovery.
    if (recovery) {
      return;
    }

    updatePostLock(settings.postLock);
    setupEditor(post, initialEdits, settings.template);

    if (settings.autosave) {
      createWarningNotice(__('There is an autosave of this post that is more recent than the version below.'), {
        id: 'autosave-exists',
        actions: [{
          label: __('View the autosave'),
          url: settings.autosave.editLink
        }]
      });
    }

    return function () {
      __experimentalTearDownEditor();
    };
  }, []); // Synchronize the editor settings as they change

  useEffect(function () {
    updateEditorSettings(settings);
  }, [settings]);

  if (!isReady) {
    return null;
  }

  return createElement(EntityProvider, {
    kind: "root",
    type: "site"
  }, createElement(EntityProvider, {
    kind: "postType",
    type: post.type,
    id: post.id
  }, createElement(BlockContextProvider, {
    value: defaultBlockContext
  }, createElement(BlockEditorProvider, {
    value: blocks,
    onChange: onChange,
    onInput: onInput,
    selectionStart: selectionStart,
    selectionEnd: selectionEnd,
    settings: editorSettings,
    useSubRegistry: false
  }, children, createElement(ReusableBlocksMenuItems, null)))));
}

export default withRegistryProvider(EditorProvider);
//# sourceMappingURL=index.js.map