import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import { get, unescape as unescapeString, debounce, flatMap, repeat, find } from 'lodash';
/**
 * WordPress dependencies
 */

import { __ } from '@wordpress/i18n';
import { ComboboxControl } from '@wordpress/components';
import { useState, useMemo } from '@wordpress/element';
import { useSelect, useDispatch } from '@wordpress/data';
/**
 * Internal dependencies
 */

import { buildTermsTree } from '../../utils/terms';

function getTitle(post) {
  var _post$title;

  return post !== null && post !== void 0 && (_post$title = post.title) !== null && _post$title !== void 0 && _post$title.rendered ? post.title.rendered : "#".concat(post.id, " (").concat(__('no title'), ")");
}

export function PageAttributesParent() {
  var _useDispatch = useDispatch('core/editor'),
      editPost = _useDispatch.editPost;

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      fieldValue = _useState2[0],
      setFieldValue = _useState2[1];

  var isSearching = fieldValue;

  var _useSelect = useSelect(function (select) {
    var _select = select('core'),
        getPostType = _select.getPostType,
        getEntityRecords = _select.getEntityRecords,
        getEntityRecord = _select.getEntityRecord;

    var _select2 = select('core/editor'),
        getCurrentPostId = _select2.getCurrentPostId,
        getEditedPostAttribute = _select2.getEditedPostAttribute;

    var postTypeSlug = getEditedPostAttribute('type');
    var pageId = getEditedPostAttribute('parent');
    var pType = getPostType(postTypeSlug);
    var postId = getCurrentPostId();
    var isHierarchical = get(pType, ['hierarchical'], false);
    var query = {
      per_page: 100,
      exclude: postId,
      parent_exclude: postId,
      orderby: 'menu_order',
      order: 'asc',
      _fields: 'id,title,parent'
    }; // Perform a search when the field is changed.

    if (isSearching) {
      query.search = fieldValue;
    }

    return {
      parentPostId: pageId,
      parentPost: pageId ? getEntityRecord('postType', postTypeSlug, pageId) : null,
      items: isHierarchical ? getEntityRecords('postType', postTypeSlug, query) : [],
      postType: pType
    };
  }, [fieldValue]),
      parentPost = _useSelect.parentPost,
      parentPostId = _useSelect.parentPostId,
      items = _useSelect.items,
      postType = _useSelect.postType;

  var isHierarchical = get(postType, ['hierarchical'], false);
  var parentPageLabel = get(postType, ['labels', 'parent_item_colon']);
  var pageItems = items || [];

  var getOptionsFromTree = function getOptionsFromTree(tree) {
    var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return flatMap(tree, function (treeNode) {
      return [{
        value: treeNode.id,
        label: repeat('â€” ', level) + unescapeString(treeNode.name)
      }].concat(_toConsumableArray(getOptionsFromTree(treeNode.children || [], level + 1)));
    });
  };

  var parentOptions = useMemo(function () {
    var tree = pageItems.map(function (item) {
      return {
        id: item.id,
        parent: item.parent,
        name: getTitle(item)
      };
    }); // Only build a hierarchical tree when not searching.

    if (!isSearching) {
      tree = buildTermsTree(tree);
    }

    var opts = getOptionsFromTree(tree); // Ensure the current parent is in the options list.

    var optsHasParent = find(opts, function (item) {
      return item.value === parentPostId;
    });

    if (parentPost && !optsHasParent) {
      opts.unshift({
        value: parentPostId,
        label: getTitle(parentPost)
      });
    }

    return opts;
  }, [pageItems]);

  if (!isHierarchical || !parentPageLabel) {
    return null;
  }
  /**
   * Handle user input.
   *
   * @param {string} inputValue The current value of the input field.
   */


  var handleKeydown = function handleKeydown(inputValue) {
    setFieldValue(inputValue);
  };
  /**
   * Handle author selection.
   *
   * @param {Object} selectedPostId The selected Author.
   */


  var handleChange = function handleChange(selectedPostId) {
    editPost({
      parent: selectedPostId
    });
  };

  return createElement(ComboboxControl, {
    className: "editor-page-attributes__parent",
    label: parentPageLabel,
    value: parentPostId,
    options: parentOptions,
    onFilterValueChange: debounce(handleKeydown, 300),
    onChange: handleChange
  });
}
export default PageAttributesParent;
//# sourceMappingURL=parent.js.map